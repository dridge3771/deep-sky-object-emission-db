/************************************************************
 * SkyPix Planner — Definitive Backend Code (Alpha 43)
 ************************************************************/
function clearTestApiKeys() {
  const properties = PropertiesService.getScriptProperties();
  properties.deleteProperty('CSE_KEY');
  properties.deleteProperty('CSE_CX'); 
  properties.deleteProperty('AIRNOW_KEY');
  Logger.log('Test keys cleared - users will need to enter their own');
}
function testSaveKeys() {
  try {
    const testKeys = {
      'CSE_KEY': 'test123',
      'CSE_CX': 'test456'
    };
    setApiKeys_(testKeys);
    Logger.log('Save test completed');
  } catch (e) {
    Logger.log('Save test failed: ' + e.message);
  }
}
// ======================= DEBUGGING UTILITY =======================
const IS_DEBUG_MODE = true;

function logDebug_(message) {
  if (IS_DEBUG_MODE) {
    Logger.log(message);
  }
}
function debugApiKeys() {
  const props = PropertiesService.getScriptProperties().getProperties();
  Logger.log('All stored properties:');
  for (const key in props) {
    Logger.log(key + ': ' + (props[key] ? props[key].substring(0, 10) + '...' : 'empty'));
  }
}
/* ======================= PUBLIC ENTRY ======================= */
/* ===== MENU-OPEN — START (safe) ===== */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  const menu = ui.createMenu('SkyPix Planner');

  menu.addItem('Build All', 'SkyPix_BuildAll');

  const buildSubMenu = ui.createMenu('Build Individual Sheets')
    .addItem('Build Object Entry', 'SkyPix_BuildObjectEntry')
    .addItem('Build Setup', 'SkyPix_BuildSetup')
    .addItem('Build Rig Kit', 'SkyPix_BuildRigKit')
    .addItem('Build Camera Kit', 'SkyPix_BuildCameraKit')
    .addItem('Build Filter Kit', 'SkyPix_BuildFilterKit')
    .addItem('Build Object Database', 'SkyPix_BuildObjectDatabase');
  menu.addSubMenu(buildSubMenu);

  const toolsSubMenu = ui.createMenu('Tools')
    .addItem('Find Location by Address...', 'showLocationFinder')
    .addItem('Add 25 Object Rows', 'SkyPix_AddObjects_')
    .addItem('Test Object Lookup (active row)', 'SkyPix_Debug_TestObjectFetch_');
  menu.addSubMenu(toolsSubMenu);

  const adminSubMenu = ui.createMenu('Admin')
    .addItem('Set API Keys...', 'showApiKeysDialog_')
    .addItem('Authorize Script (First-Time Use)', 'SkyPix_Authorize_')
    .addSeparator()
    .addItem('Set API Keys (Manual)', 'setApiKeysManually')
    .addItem('Enable onEdit Trigger', 'SkyPix_EnableOnEdit_')
    .addItem('!!! Delete All Sheets !!!', 'deleteAllSkyPixSheets_')
    .addItem('Resolve Pasted List…', 'showResolveProgress_')
    .addItem('Fix Zenith/Landscape layout', 'run_fix_zenith_landscape_')
    .addItem('Restore Rig color picker',    'rigkit_restoreColorPicker_');
  menu.addSubMenu(adminSubMenu);

  menu.addToUi();

  try { installOnEditTrigger_(); }
  catch (err) {
    SpreadsheetApp.getActive().toast('Note: onEdit trigger not installed. Use Admin ▸ Enable onEdit Trigger.');
  }
}

function run_fix_zenith_landscape_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (sh) rigkit_applyZenithLandscapeLayout_(sh);
}

/* ===== MENU-OPEN — END ===== */

// --- Bootstrap guard so early code can safely read FK.NAME even before FK is defined.
var FK = (typeof FK !== 'undefined') ? FK : { NAME: 'Filter Kit' };

function deleteAllSkyPixSheets_() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.alert('Are you sure you want to permanently delete all SkyPix Planner sheets?', ui.ButtonSet.YES_NO);
  if (response !== ui.Button.YES) return;
  const ss = SpreadsheetApp.getActive();
  const sheetNamesToDelete = ['_config', 'Object Entry', 'Setup', 'Rig kit', CK.NAME, FK.NAME, 'Object Database', 'Setup Parameters', 'Sensor Kit'];
  sheetNamesToDelete.forEach(name => {
    const sheet = ss.getSheetByName(name);
    if (sheet) ss.deleteSheet(sheet);
  });
  ss.toast('All SkyPix Planner sheets have been deleted.');
}

function onEditTrigger(e) {
  const lock = LockService.getScriptLock();
  const hasLock = lock.tryLock(15000);
  if (!hasLock) return;
  try {
    if (!e || !e.range) {        // <— guard for manual runs
      Logger.log('onEditTrigger invoked without event; ignoring.');
      return;
    }
    logDebug_(`EDIT on ${e.range.getSheet().getName()}@${e.range.getA1Notation()} | Value: ${e.value}`);
    SkyPix_DispatchOnChange_(e);
  } catch (err) {
    logDebug_('CRITICAL ERROR in onEditTrigger: ' + err.stack);
  } finally {
    lock.releaseLock();
  }
  camerakit_handleColorPicker_(e);
}


function createOnEditTrigger_() {
  const ss = SpreadsheetApp.getActive();
  ScriptApp.getProjectTriggers().forEach(trigger => {
    if (trigger.getHandlerFunction() === 'onEditTrigger') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  ScriptApp.newTrigger('onEditTrigger').forSpreadsheet(ss).onEdit().create();
}

function SkyPix_BuildAll() {
  const ss = SpreadsheetApp.getActive();
  _createConfigSheet_(ss);
  buildObjectEntrySheet_(ss);
  buildSetup_(ss);
  buildRigKit_(ss);
  buildCameraKit_(ss);
  buildFilterKit_(ss);
  buildObjectDatabase_(ss);
}

function SkyPix_Authorize_() {
  try {
    UrlFetchApp.fetch('https://www.google.com');
    PropertiesService.getScriptProperties().getKeys();
    SpreadsheetApp.getActive().toast('SkyPix Planner has been successfully authorized.');
  } catch (e) {
    SpreadsheetApp.getActive().toast('Authorization process initiated. Please review and allow permissions.');
  }
}
function SkyPix_EnableOnEdit_() {
  installOnEditTrigger_();
  SpreadsheetApp.getActive().toast('onEdit trigger enabled.');
}

/* ======================= ON EDIT DISPATCHER ======================= */
function onEditTrigger(e) {
  const scriptLock = LockService.getScriptLock();
  const hasLock = scriptLock.tryLock(15000);
  if (!hasLock) return;
  try {
    logDebug_(`EDIT on ${e.range.getSheet().getName()}@${e.range.getA1Notation()} | Value: ${e.value}`);
    SkyPix_DispatchOnChange_(e);
  } catch (err) {
    logDebug_('CRITICAL ERROR in onEditTrigger: ' + err.stack);
  } finally {
    scriptLock.releaseLock();
  }
}

function SkyPix_DispatchOnChange_(e) {
  const sh = e.range.getSheet();
  const sheetName = sh.getName();
  const a1 = e.range.getA1Notation();
  const val = e.value;
  const oldVal = e.oldValue;
  const editRow = e.range.getRow();
  const editCol = e.range.getColumn();
  const label = sh.getRange(editRow, 1).getDisplayValue();

  if ((sheetName === 'Setup' && (a1 === 'C12' || a1 === 'C13')) || (sheetName === 'Rig kit' && label.includes('Rig highlight color')) || (sheetName === CK.NAME && editRow === CK.ROWS.COLOR && editCol > 1) || (sheetName === FK.NAME && label === FK.HIGHLIGHT_COLOR_LABEL)) {
    paintColorCell_(e.range, val);
    if (sheetName === 'Setup' && a1 === 'C12') {
      recolorAllSheets_();
} else {
        RK_handleCellEdit_(e);
      }
    return;
  }

  const bg = e.range.getBackground().toLowerCase();
  if (bg === WARN_ORANGE.toLowerCase() || bg === WARN_YELLOW.toLowerCase()) {
    if (isValueValid_(val, e.range)) {
      e.range.setBackground(null);
    }
  }

  if (val === oldVal && !(sheetName.endsWith('Kit') && a1 === 'A3')) return;
  
  if (sheetName === 'Setup') {
    if (a1 === 'C4' && val === 'Retrieve 4D Location') {
      showLocationFinder('Setup');
      e.range.setValue('');
    } else if (a1 === 'C21' && val === 'TRUE') {
      sh.getRange('C18:C20').setBackground(null);
    } else {
      setRefreshBarYellow_(sh);
    }
    return;
  }

  switch (sheetName) {
  case 'Object Entry':
  if (editCol === 1 && editRow > 4 && val) {
    const rng = e.range;

    // If a block was pasted, run the batch flow with progress pie
    if (rng.getNumRows() > 1 || rng.getNumColumns() > 1) {
      showResolveProgress_();   // <— instead of SkyPix_BulkResolveRange_(rng)
      return;
    }

    // Single cell edit → resolve one
    const out = fetchSimbadData(rng);
    if (out === 'Success') setRefreshBarYellow_(sh);
    return;
  }

  if (editRow === 2 && val === 'Refresh Database') {
  processObjectEntries_();
  styleRefreshBarNeutral_(sh);
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_DB_ONLY);
}
  break;


  // Keep the existing "Update Database" flow
  if (editRow === 2 && val === 'Update Database') {
    processObjectEntries_();
    rigkit_resetRefreshBar_(sh);
  }
  break;
    case 'Rig kit':
    // Keep first-line refresh actions here
      if (editRow === 2) {
      if (val === 'Refresh Kits') {
        refreshKits_();
        rigkit_resetRefreshBar_(sh);
        return;
      }
      if (editRow === 2 && val === 'Refresh Kits') {
        rebuildRigEligibility_Camera_();
        rebuildRigEligibility_Filter_();
        styleRefreshBarNeutral_(sh);
      return;
      }

      if (val === 'Refresh Air Quality Index') {
        updateAllRigAirQuality();
        rigkit_resetRefreshBar_(sh);
        return;
      }
      if (val === 'Refresh Bortle Class') {
        updateAllRigBortleClass();
        rigkit_resetRefreshBar_(sh);
        return;
      }
      if (val === 'Refresh Planner') {
        // your existing planner glue, then:
        rigkit_resetRefreshBar_(sh);
        return;
      }
      // (Optional) If you want "Refresh Database" from Rig kit to push Object Entry → DB:
      // if (val === 'Refresh Database') { processObjectEntries_(); rigkit_resetRefreshBar_(sh); return; }
    }

      if (editRow === 2 && val === 'Refresh Air Quality Index') {
        updateAllRigAirQuality();
        
        rigkit_resetRefreshBar_(sh);
        return;
      } else if (editRow === 2 && val === 'Refresh Bortle Class') {
        updateAllRigBortleClass();
       
        rigkit_resetRefreshBar_(sh);
        return;
        }
        else if (editRow === 2 && val === 'Refresh Planner') {
      // This would update any planner sheets that depend on rig data
      // e.g., recalculate observing windows, update equipment compatibility
      // New: Refresh Kits (updates Camera & Filter kits from Rig data)
      if (editRow === 2 && val === 'Refresh Kits') {
        refreshKits_();
        rigkit_resetRefreshBar_(sh);
        return;
      }

    rigkit_resetRefreshBar_(sh);
    return;
}
         else if (editRow === 9 && val === 'Retrieve 4D Location') {
        showLocationFinder('Rig kit', e.range.getA1Notation());
        e.range.setValue(''); 
        return;
  }if (editRow === 9 && val === 'Retrieve 4D Location') {
        showLocationFinder('Rig kit', e.range.getA1Notation());
        e.range.setValue('');
        return;
      } else if (a1 === 'A3' && val === 'Add Rig') {
        SkyPix_AddRig_();
        e.range.setValue('Add Rig...');
      } else if (editRow === 3 && (!val || val.trim() === '')) {
        const ui = SpreadsheetApp.getUi();
        const response = ui.alert(`Are you sure you want to delete rig "${oldVal}"?`, ui.ButtonSet.YES_NO);
        if (response == ui.Button.YES) {
          sh.deleteColumns(editCol, 2);
     } else {
          e.range.setValue(oldVal);
        }
      } else if (editRow === 3 && val !== oldVal) {
        rigkit_forceColorPicker_();
        rigkit_resetRefreshBar_(sh);
      } 
        else if (editRow === 23) {
        rebuildRigEligibility_Camera_();
        rebuildRigEligibility_Filter_();
      } else {
        setRefreshBarYellow_(sh);
      }
      break;
    case CK.NAME:
      if (a1 === 'A3' && val === 'Add Camera') {
        SkyPix_AddCamera_();
        e.range.setValue('Add Camera...');
      } else {
        setRefreshBarYellow_(sh);
      }
      break;
    case FK.NAME:
      if (editRow === 2 && val === 'Refresh Planner') {
        handlePlannerUpdate_();
        
        styleRefreshBarNeutral_(sh);
      } else if (a1 === 'A3' && val && val.startsWith('Add')) {
        SkyPix_AddFilter_(val);
        e.range.setValue('Add Filter...');
      } else if (editRow === 3 && (!val || val.trim() === '')) {
        const ui = SpreadsheetApp.getUi();
        const response = ui.alert(`Are you sure you want to delete filter "${oldVal}"?`, ui.ButtonSet.YES_NO);
        if (response == ui.Button.YES) {
          const mergedRange = e.range.getMergedRanges()[0];
          sh.deleteColumns(mergedRange.getColumn(), mergedRange.getWidth());
          rebuildFilterKitLayout_();
        } else {
          e.range.setValue(oldVal);
        }
      } else {
        if (label === FK.BAND_ID_LABEL) {
          const block = getFilterBlockForColumn_(sh, editCol);
          if (block) {
            populateDefaultBandData_(sh, editCol, val);
            populateTransmissionCurve_(sh, editCol, val);
            sh.getRange(FK.ROWS.MODEL, block.startCol, (FK.ROWS.SUBSTRATE - FK.ROWS.MODEL + 1), block.width).setBackground(WARN_ORANGE);
            sh.getRange(FK.ROWS.ACK, block.startCol).setValue(false);
          }
        } else if (editRow === FK.ROWS.ACK && val === 'TRUE') {
          const block = getFilterBlockForColumn_(sh, editCol);
          if (block) {
            sh.getRange(FK.ROWS.MODEL, block.startCol, (FK.ROWS.SUBSTRATE - FK.ROWS.MODEL + 1), block.width).setBackground(null);
            const curveHeaderRow = findRowWithText_(sh, 'Transmission Curve');
            if (curveHeaderRow) {
              sh.getRange(curveHeaderRow + 2, block.startCol, 10, block.width).setBackground(null);
            }
          }
        }
        setRefreshBarYellow_(sh);
      }
      break;
    case 'Object Database':
      if (editCol === 1 && editRow > 4 && val && val.startsWith('Smart Search')) {
        SpreadsheetApp.getActive().toast(`Running "${val}" for object: ${oldVal || ''}`);
        e.range.setValue(oldVal);
      }
      break;
  }
}

function showResolveProgress_(){
  const html = HtmlService.createHtmlOutput(
    `<!DOCTYPE html><html><head><meta name="google-apps-script-cando" content="true">
     <style>body{font-family:Arial;text-align:center;padding:14px}#s{font-weight:bold}</style></head>
     <body><div>Resolving objects…</div><div id="s">Starting…</div>
     <script>
       function step(){
         google.script.run.withSuccessHandler(function(res){
           document.getElementById('s').textContent = res.message || '';
           if (res.done){ setTimeout(()=>google.script.host.close(), 900); }
           else { setTimeout(step, 250); }
         }).doResolveBatch_();
       }
       window.addEventListener('load', step);
     </script></body></html>`
  ).setWidth(300).setHeight(140);
  SpreadsheetApp.getUi().showModalDialog(html,'Processing Objects…');
}

function doResolveBatch_(){
  const sh = SpreadsheetApp.getActive().getSheetByName('Object Entry');
  if (!sh) return {message:'Sheet not found', done:true};

  const { batchSize, auto } = _getBatchPrefs_();
  const props = PropertiesService.getScriptProperties();
  const lastRow = sh.getLastRow();

  // find where to start
  let row = Number(props.getProperty('SPX_RESOLVE_NEXT_ROW') || 5);
  let processed = 0;

  for (; row <= lastRow && processed < batchSize; row++){
    const id = String(sh.getRange(row,1).getDisplayValue() || '').trim();
    if (!id) continue;
    const st = String(sh.getRange(row,7).getDisplayValue() || '');
    if (st === 'Success' || st === 'Duplicate') continue;
    fetchSimbadData(sh.getRange(row,1));
    processed++;
    Utilities.sleep(120);
  }

  if (row > lastRow){
    props.deleteProperty('SPX_RESOLVE_NEXT_ROW');
    return { message: `Resolved ${processed} object(s). Done.`, done: true };
  } else {
    props.setProperty('SPX_RESOLVE_NEXT_ROW', String(row));
    if (auto) return { message: `Resolved ${processed} object(s). Continuing…`, done: false };
    return { message: `Resolved ${processed} object(s).`, done: true };
  }
}

/* ======================= Bulk Object Entry Resolving ======================= */

function SkyPix_BulkResolveRange_(rng){
  const sh = rng.getSheet();
  if (sh.getName() !== 'Object Entry') return;

  const start = Math.max(5, rng.getRow());                 // only rows ≥ 5
  const end   = start + rng.getNumRows() - 1;

  let resolved = 0;
  for (let r = start; r <= end; r++){
    const id = sh.getRange(r, 1).getDisplayValue().trim(); // A-column value
    if (!id) continue;

    const out = fetchSimbadData(sh.getRange(r, 1));        // resolve this row
    if (out === 'Success' || out === 'Duplicate') resolved++;

    Utilities.sleep(120);                                   // be gentle to APIs
  }

  if (resolved > 0) {
    // Turn the bar yellow and show the two choices
    setRefreshBarYellow_(sh);
  }

  SpreadsheetApp.getActive().toast(`Resolved ${resolved} object(s).`);
}

function SkyPix_BulkResolveSelected_(){
  const sh = SpreadsheetApp.getActiveSheet();
  if (!sh || sh.getName() !== 'Object Entry'){
    SpreadsheetApp.getUi().alert('Select a range on the "Object Entry" sheet.');
    return;
  }
  const rng = sh.getActiveRange();
  if (!rng) return;

  const firstRow = Math.max(5, rng.getRow());
  const lastRow  = rng.getLastRow();
  SkyPix_BulkResolveRange_(sh.getRange(firstRow, 1, lastRow - firstRow + 1, 1));
}


/* ======================= CANON CONSTANTS & HELPERS ======================= */
const TITLE_FS = 16, HEADER_FS = 12, LABEL_FS = 10, REFRESH_FS = 12;
const ROW_H_ALL = 36, ROW_H_HORIZON = 21, ROW_H_CURVE = 21;
const REFRESH_CHOICES_RIG = ['Refresh Kits', 'Refresh Air Quality Index', 'Refresh Bortle Class', 'Refresh Database', 'Refresh Planner', 'Cancel'];
const REFRESH_CHOICES_CAMERA = ['Refresh planner', 'Retrieve specifications', 'Cancel'];
const REFRESH_CHOICES_FILTER = ['Refresh planner', 'Retrieve specifications', 'Cancel'];
const REFRESH_CHOICES_DEFAULT = ['Refresh', 'Refresh Kits', 'Refresh Database'];
const REFRESH_CHOICES_DB_ONLY = ['Refresh Database', 'Cancel'];
const REFRESH_LABEL_OPTION = 'Refresh';  // non-action label shown in the bar
const REFRESH_LABEL          = 'Refresh';             // default label
const CANCEL_LABEL           = 'Cancel';              // secondary action
const REFRESH_DB_LABEL       = 'Refresh Database';    // Object Entry special case

// Default choices for most sheets
const REFRESH_CHOICES        = [REFRESH_LABEL, CANCEL_LABEL];

// Optional: small visual nudge so the caret doesn't crowd the text
const REFRESH_LEFT_PAD_PX    = 8;
function padRefreshLabel_(s, px = REFRESH_LEFT_PAD_PX) {
  // ~6 px per NBSP at 10pt Arial; tweak if you change font/size
  const n = Math.max(0, Math.round(px / 6));
  return '\u00A0'.repeat(n) + s;
}
/* ===== PRECISION SETTINGS ===== */
const LATLON_DECIMALS = 4;   // 4 dp for lat/lon; elevation is integer elsewhere
const DEFAULT_HPC = '#4472c4'; 
const WARN_YELLOW = '#ffff00', WARN_ORANGE = '#ffa500';
const REFRESH_NEUTRAL_BG = '#e8e8e8';
const DARK_GREY_FONT = '#434343';

const COLOR_PICKER = [['Blue', '#1E90FF'], ['Deep Blue', '#0047AB'], ['Steel Blue', '#4682B4'], ['Cyan', '#00BCD4'], ['Light Blue', '#87CEFA'], ['Cornflower', '#6495ED'], ['Green', '#2E8B57'], ['Teal', '#008080'], ['Purple', '#7E57C2'], ['Magenta', '#D81B60'], ['Red', '#E53935'], ['Red Berry', '#9B111E'], ['Maroon', '#800000'], ['Brown', '#795548'], ['Slate', '#708090'], ['Navy', '#001F3F'], ['Dk Green', '#006400']];
const RDEF_LABELS = ['Rig model', 'Aperture (mm)', 'Central obstruction (mm)', 'Effective aperture area (mm²)', 'Effective focal length (mm)', 'Latitude (°) [N + / S -]', 'Longitude (°) [E + / W -]', 'Elevation above sea level (m)', 'Timezone UTC ±', 'DST start (MM-DD-YY)', 'DST end (MM-DD-YY)'];
const DFS_LABELS = ['Darkness convention', 'Times reported based on', 'Visibility reported as', 'Offset of transit/rising (minutes)', 'Display objects observable for the next... (months)', 'Display objects between declinations... (degrees)', 'Rig highlight color'];
const IMC_LABELS = [
  'Maximum integration time',
  'Maximum subframe exposure (seconds)',
  'Minimum object elevation (degrees)',
  'Expected ambient temp (°C)',
  'Sky Brightness',                        // was “Bortle class”
  'Air quality index',                     // stays, moved up with Sky Brightness
  'Minimum contiguous imaging time (min)', // new; replaces K (λ)
  'Lunar avoidance angle (degrees)'
];

function getLandHdrRow_(sh) {
  // Find the "Landscape Horizon" header row.
  let row = findRowWithText_(sh, 'Landscape Horizon');
  if (row) return row;

  // If it doesn't exist yet, create a minimal section and return its header row.
  const afterZenith = findRowWithText_(sh, 'Zenith Obstruction');
  const insertAt = (afterZenith ? afterZenith + 2 : Math.max(1, sh.getLastRow()) + 2);

  // Insert 3 rows: header + labels
  sh.insertRows(insertAt, 3);

  // Header (merged across A:C so it plays nicely with your layout)
  sh.getRange(insertAt, 1, 1, 3)
    .merge()
    .setValue('Landscape Horizon')
    .setHorizontalAlignment('left')
    .setVerticalAlignment('middle');

  // Column labels (Az/Alt) directly below the header so your later formatting calls work
  sh.getRange(insertAt + 1, 2).setValue('Az');
  sh.getRange(insertAt + 1, 3).setValue('Alt');

  return insertAt;
}

function getRefreshChoicesForSheet_(sh) {
  const name = sh && sh.getName ? sh.getName() : '';
  if (name === 'Rig kit')                 return REFRESH_CHOICES_RIG;
  if (name === CK.NAME)                   return REFRESH_CHOICES_CAMERA;
  if (name === FK.NAME)                   return ['Refresh Planner', 'Cancel'];
  if (name === 'Object Entry')            return REFRESH_CHOICES_DB_ONLY;
  // Setup / Object Database / anything else
  return REFRESH_CHOICES;
}

function getHPC_Global_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Setup');
  if (!sh) return DEFAULT_HPC;

  // Find the row that has the label “Header Primary Color”
  const row = findRowWithText_(sh, 'Header Primary Color');
  if (!row) return DEFAULT_HPC;

  const cell = sh.getRange(row, 3); // column C holds the picker
  const bg = (cell.getBackground() || '').toLowerCase();
  if (bg && bg !== '#ffffff') return bg;  // use the swatch color if present

  // Fallback to the dropdown text → hex map you already have
  const name = (cell.getDisplayValue() || '').trim();
  const hex  = nameToHex_(name);
  return hex || DEFAULT_HPC;
}


function _withRefreshLabelOption_(choices){
  const arr = (choices && choices.length) ? choices.slice() : [];
  if (!arr.includes(REFRESH_LABEL_OPTION)) arr.unshift(REFRESH_LABEL_OPTION);
  return arr;
}

function recolorAllSheets_() {
  const ss = SpreadsheetApp.getActive();
  recolorSetupSheet_(ss.getSheetByName('Setup'));
  recolorObjectEntrySheet_(ss.getSheetByName('Object Entry'));   // ← add
  recolorRigKitBands_(ss.getSheetByName('Rig kit'));
  recolorCameraKitBands_(ss.getSheetByName(CK.NAME));
  recolorFilterKitBands_(ss.getSheetByName(FK.NAME));
  recolorObjectDatabase_(ss.getSheetByName('Object Database'));  // ← add (needs Patch B)
}

function getSkyPixConfig(){
  const p = PropertiesService.getScriptProperties().getProperties() || {};
  return {
    cseKey:        p.CSE_KEY || '',
    cseCx:         p.CSE_CX || '',
    airNowApiKey:  p.AIRNOW_KEY || '',
    astrobinKey:   p.ASTROBIN_KEY || '',
    equipmentKey:  p.EQUIPMENT_API_KEY || '',
    lpollutionKey: p.LPOLLUTION_KEY || ''
  };
}

/* ===== SETUP-LATLON-HELPERS — START (SAFE) ===== */
// Show the “Retrieve 4D Location” dropdown in C4 even after values are filled?
// Leave true to always keep the dropdown visible.
const C4_DROPDOWN_ALWAYS_VISIBLE = true;

function setupSheet_(sh) {
  // Fallback to the Setup sheet if nothing passed.
  return sh || SpreadsheetApp.getActive().getSheetByName('Setup') || null;
}

function setSetupLocationFinderDropdown_(sh) {
  sh = setupSheet_(sh); if (!sh) return;
  const dv = SpreadsheetApp.newDataValidation()
    .requireValueInList(['Retrieve 4D Location', 'Cancel'], true)
    .setAllowInvalid(true)
    .build();
  sh.getRange('C4').setDataValidation(dv);
}

function setSetupLatLonValidation_(sh) {
  sh = setupSheet_(sh); if (!sh) return;
  const dvLat = SpreadsheetApp.newDataValidation().requireNumberBetween(-90, 90).setAllowInvalid(true).build();
  const dvLon = SpreadsheetApp.newDataValidation().requireNumberBetween(-180, 180).setAllowInvalid(true).build();
  const dvEle = SpreadsheetApp.newDataValidation().requireNumberBetween(-1000, 10000).setAllowInvalid(true).build();
  sh.getRange('C4').setDataValidation(dvLat);   // latitude
  sh.getRange('C5').setDataValidation(dvLon);   // longitude
  sh.getRange('C7').setDataValidation(dvEle);   // elevation
}
/* ===== SETUP-LATLON-HELPERS — END (SAFE) ===== */

function SkyPix_Debug_TestObjectFetch_(){
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Object Entry');
  if (!sh) return ss.toast('Object Entry not found.');
  const row = sh.getActiveCell().getRow();
  if (row < 5) return ss.toast('Click a row ≥ 5 in column A with an Object ID first.');
  const aCell = sh.getRange(row, 1);
  if (!aCell.getDisplayValue()) return ss.toast('Enter an Object ID in column A first (e.g., M42).');
  const res = fetchSimbadData(aCell);
  ss.toast('Lookup result: ' + res);
}

/* ===== NUMBER-FORMAT HELPERS — START ===== */
function enforceSetupFormats_(sh) {
  sh = sh || SpreadsheetApp.getActive().getSheetByName('Setup');
  if (!sh) return;
  sh.getRange('C4:C5').setNumberFormat('0.' + '0'.repeat(LATLON_DECIMALS)); // lat/lon
  sh.getRange('C7').setNumberFormat('0');                                   // elevation
  sh.getRange('C8:C9').setNumberFormat('MM-dd-yy');                         // dates (unchanged)
}

function enforceRigFormats_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  getPairsFromHeaders_(sh).forEach(([cL]) => {
    sh.getRange(9,  cL, 1, 2).setNumberFormat('0.' + '0'.repeat(LATLON_DECIMALS)); // lat
    sh.getRange(10, cL, 1, 2).setNumberFormat('0.' + '0'.repeat(LATLON_DECIMALS)); // lon
    sh.getRange(11, cL, 1, 2).setNumberFormat('0');                                // elevation
  });
}
/* ===== NUMBER-FORMAT HELPERS — END ===== */
function SkyPix_CSE_(query, num) {
  const { cseKey, cseCx } = getSkyPixConfig();
  if (!cseKey || !cseCx) throw new Error('Missing CSE key/cx (Admin → Set API Keys…)');

  const url = 'https://customsearch.googleapis.com/customsearch/v1'
            + '?key=' + encodeURIComponent(cseKey)
            + '&cx='  + encodeURIComponent(cseCx)
            + '&num=' + encodeURIComponent(num || 3)
            + '&q='   + encodeURIComponent(query);

  const resp = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
  const data = JSON.parse(resp.getContentText() || '{}');
  if (resp.getResponseCode() !== 200) {
    throw new Error('CSE error ' + resp.getResponseCode() + ': ' + (data.error && data.error.message || ''));
  }
  return (data.items || []).map(i => ({ title: i.title, link: i.link, snippet: i.snippet }));
}
/* =========== On-Edit Trigger Helpers =============*/
/** Ensure the installable onEdit trigger exists (idempotent). */
function ensureOnEditTrigger_() {
  const ss = SpreadsheetApp.getActive();
  const triggers = ScriptApp.getProjectTriggers();

  // Remove broken/duplicate onEdit triggers for safety
  triggers.forEach(t => {
    if (t.getHandlerFunction() === 'onEditTrigger' && t.getEventType() === ScriptApp.EventType.ON_EDIT) {
      // keep exactly one; delete extras below
    }
  });

  const exists = triggers.some(t =>
    t.getHandlerFunction() === 'onEditTrigger' &&
    t.getEventType && t.getEventType() === ScriptApp.EventType.ON_EDIT
  );

  if (!exists) {
    ScriptApp.newTrigger('onEditTrigger')
      .forSpreadsheet(ss)      // bind to this sheet
      .onEdit()
      .create();
  }
}

/** Back-compat alias if any code still calls the old name. */
function installOnEditTrigger_() { ensureOnEditTrigger_(); }

/** Menu action: Enable onEdit Trigger */
function SkyPix_EnableOnEdit_() {
  try {
    ensureOnEditTrigger_();
    SpreadsheetApp.getActive().toast('onEdit trigger enabled.');
  } catch (e) {
    SpreadsheetApp.getActive().toast('Error enabling onEdit: ' + e.message);
  }
}

/** Optional: quick debugger to see triggers */
function SkyPix_Debug_ListTriggers_() {
  const lines = ScriptApp.getProjectTriggers().map(t =>
    `${t.getHandlerFunction()} — ${t.getEventType && t.getEventType()}`
  );
  Logger.log(lines.join('\n') || 'No triggers found');
}

function onEditTrigger(e) {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(15000)) return;
  try {
    if (!e || !e.range) { Logger.log('onEditTrigger called without event; ignoring.'); return; }
    logDebug_(`EDIT on ${e.range.getSheet().getName()}@${e.range.getA1Notation()} | Value: ${e.value}`);
    SkyPix_DispatchOnChange_(e);
  } catch (err) {
    logDebug_('CRITICAL ERROR in onEditTrigger: ' + err.stack);
  } finally {
    lock.releaseLock();
  }
}

/* ============== SIMBAD Lookup Helpers ================ */
// Normalize common IDs so SIMBAD matches (e.g., "M42" → "M 42")
function _canonObjectId_(s){
  const t = String(s||'').trim().toUpperCase();
  const m = t.match(/^M\s*0*([1-9]\d*)$/);     if (m)  return 'M '   + m[1];
  const n = t.match(/^NGC\s*0*([1-9]\d*)$/);   if (n)  return 'NGC ' + n[1];
  const ic= t.match(/^IC\s*0*([1-9]\d*)$/);    if (ic) return 'IC '  + ic[1];
  return String(s||'').trim();
}

// SESAME text fallback
function SkyPix_SESAME_(ident){
  const url  = 'https://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oI/A?' + encodeURIComponent(ident);
  const resp = UrlFetchApp.fetch(url, { muteHttpExceptions:true });
  if (resp.getResponseCode() !== 200) return null;
  const txt  = resp.getContentText();
  const jpos = txt.match(/#JPOS\s*=\s*([0-9.+-]+)\s+([0-9.+-]+)/);
  if (!jpos) return null;
  const jname= txt.match(/%J,NAME\s*=\s*(.*)/);
  return {
    main_id: (jname && jname[1] && jname[1].trim()) || ident,
    raDeg: parseFloat(jpos[1]),
    decDeg: parseFloat(jpos[2])
  };
}

// Generates SIMBAD-friendly identifier variants (Messier/NGC/IC/LBN/Sh2, combos)
function _genCandidates_(raw){
  const s = String(raw || '').trim();
  if (!s) return [];
  const out = new Set();

  const add = v => { if (v) out.add(String(v).trim()); };

  add(s);                               // as typed
  const T = s.replace(/\s+/g,' ').trim();

  // Generic "CAT####" -> "CAT ####"
  const m = T.match(/^([A-Za-z ]+)\s*([0-9][0-9A-Za-z\-]*)$/);
  if (m) add(`${m[1].trim()} ${m[2].trim()}`);

  // Messier (M42)
  let r = T.match(/^M\s*-?\s*(\d+)$/i);
  if (r){ add(`M ${r[1]}`); add(`M${r[1]}`); add(`Messier ${r[1]}`); }

  // NGC / IC / LBN / Caldwell
  [['NGC'],['IC'],['LBN'],['C','Caldwell']].forEach(([cat, alias])=>{
    r = T.match(new RegExp(`^${cat}\\s*-?\\s*(\\d+)$`,'i'));
    if (r){ add(`${cat} ${r[1]}`); add(`${cat}${r[1]}`); if (alias) add(`${alias} ${r[1]}`); }
  });

  // Sharpless (Sh 2-184, Sh2-184, Sh2 184, etc.)
  r = T.match(/^(SH2|SH\s*2)[-\s]*(\d+)$/i);
  if (r){
    const n = r[2];
    ['Sh 2-'+n,'Sh2-'+n,'Sh2 '+n,'Sh 2 '+n,'SH 2-'+n].forEach(add);
  }

  // Split combos like "NGC 281/SH2 184"
  if (/[\/,&]/.test(T)){
    T.split(/[\/,&]\s*/).forEach(p => _genCandidates_(p).forEach(add));
  }

  return Array.from(out);
}

/* =====================Object Entry Helpers =======================*/

// Split resolved label into catalog/common: "M 101 (Pinwheel Galaxy)" -> {catalog:"M 101", common:"Pinwheel Galaxy"}
function _splitResolvedName_(s){
  s = String(s || '').trim();
  if (!s) return { catalog:'', common:'' };
  const m = s.match(/^(.+?)\s*\((.+?)\)\s*$/);
  if (m) return { catalog: m[1].trim(), common: m[2].trim() };
  // Looks like a catalog-only label? leave common empty.
  if (/^(M|NGC|IC|LBN|UGC|PGC|ESO|Sh\s*2)[\s-]/i.test(s)) return { catalog: s, common: '' };
  // Otherwise treat as a plain common name
  return { catalog:'', common: s };
}

// Make a “catalog-like” ID texty & clean (no leading apostrophes Google Sheets sometimes adds)
function _cleanCatalogId_(s){
  s = String(s || '').trim();
  return s.replace(/^'/, '');   // drop a leading apostrophe if present
}

// Center a single Object Entry row (A..G)
function _centerEntryRow_(sh, row){
  sh.getRange(row, 1, 1, 7).setHorizontalAlignment('center').setVerticalAlignment('middle');
}

// Read batch preferences from Setup
function _getBatchPrefs_(){
  const setup = SpreadsheetApp.getActive().getSheetByName('Setup');
  const batchSize = Math.max(1, Number(setup?.getRange('C18').getValue() || 25));
  const auto = String(setup?.getRange('C19').getDisplayValue() || 'TRUE') === 'TRUE';
  return { batchSize, auto };
}

function _raHmsToDegrees_(s){
  const m = String(s||'').trim().match(/^(\d{1,2}):(\d{1,2}):(\d{1,2}(?:\.\d*)?)$/);
  if (!m) return NaN;
  const h = +m[1], mi = +m[2], se = +m[3];
  return (h + mi/60 + se/3600) * 15;
}

function sortObjectDatabaseByRA_(){
  const sh = SpreadsheetApp.getActive().getSheetByName('Object Database');
  if (!sh) return;

  const first = 5, last = sh.getLastRow();
  if (last < first) return;

  const width = 26; // A..Z per your layout
  const range = sh.getRange(first, 1, last - first + 1, width);
  const data  = range.getValues();

  data.sort((a, b) => {
    const raA = _raHmsToDegrees_(a[2]); // column C (0-based index 2)
    const raB = _raHmsToDegrees_(b[2]);
    if (isNaN(raA) && isNaN(raB)) return 0;
    if (isNaN(raA)) return 1;
    if (isNaN(raB)) return -1;
    return raA - raB;
  });

  range.setValues(data);
}

/* ======================= Object Entry Math ==============================*/
// ---------- Angle & time helpers ----------
const DEG2RAD = Math.PI / 180, RAD2DEG = 180 / Math.PI;

function jdFromDate_(d){ // UTC → JD
  const Y = d.getUTCFullYear(), M = d.getUTCMonth() + 1, D = d.getUTCDate();
  const h = d.getUTCHours(), m = d.getUTCMinutes(), s = d.getUTCSeconds();
  let A = Math.floor((14 - M)/12);
  let y = Y + 4800 - A, m0 = M + 12*A - 3;
  let JDN = D + Math.floor((153*m0 + 2)/5) + 365*y + Math.floor(y/4) - Math.floor(y/100) + Math.floor(y/400) - 32045;
  const fracDay = (h + (m + s/60)/60) / 24;
  return JDN + fracDay - 0.5; // astronomical JD starts at noon
}

function julianCenturiesSinceJ2000_(jd){ return (jd - 2451545.0)/36525; }

// Meeus precession J2000 → epoch-of-date (zeta, z, theta in arcsec)
function precessionAnglesJ2000_(T){
  const t = T; // centuries since J2000
  const zeta  = (2306.2181*t + 0.30188*t*t + 0.017998*t*t*t) * (1/3600) * DEG2RAD;
  const z     = (2306.2181*t + 1.09468*t*t + 0.018203*t*t*t) * (1/3600) * DEG2RAD;
  const theta = (2004.3109*t - 0.42665*t*t - 0.041833*t*t*t) * (1/3600) * DEG2RAD;
  return { zeta, z, theta };
}

// Precess J2000 (ra,dec in deg) → equinox-of-date (deg)
function precessJ2000ToDate_(raDeg, decDeg, when){
  const jd = jdFromDate_(when), T = julianCenturiesSinceJ2000_(jd);
  const { zeta, z, theta } = precessionAnglesJ2000_(T);

  let ra = raDeg * DEG2RAD, dec = decDeg * DEG2RAD;

  const A = Math.cos(dec) * Math.sin(ra + zeta);
  const B = Math.cos(theta) * Math.cos(dec) * Math.cos(ra + zeta) - Math.sin(theta) * Math.sin(dec);
  const C = Math.sin(theta) * Math.cos(dec) * Math.cos(ra + zeta) + Math.cos(theta) * Math.sin(dec);

  const ra2  = (Math.atan2(A, B) + z) * RAD2DEG;
  const dec2 = Math.asin(C) * RAD2DEG;
  return { raDeg: (ra2 + 360) % 360, decDeg: dec2 };
}

// Apply proper motion (mas/yr) from J2000 to 'when' (deg → deg)
function applyProperMotion_(raDeg, decDeg, pmraMasYr, pmdecMasYr, when){
  if (!pmraMasYr && !pmdecMasYr) return { raDeg, decDeg };
  const years = (jdFromDate_(when) - 2451545.0) / 365.25;
  const decRad = decDeg * DEG2RAD;
  const dRAdeg  = (pmraMasYr ? (pmraMasYr / (3.6e6 * Math.max(Math.cos(decRad), 1e-6))) : 0) * years; // μα* / cosδ
  const dDEdeg  = (pmdecMasYr ? (pmdecMasYr / 3.6e6) : 0) * years;
  return { raDeg: raDeg + dRAdeg, decDeg: decDeg + dDEdeg };
}

// Convenience: J2000 + pm → JNow (today), in deg
function toEpochOfDate_(raJ2000Deg, decJ2000Deg, pmraMasYr, pmdecMasYr, when){
  const withPM  = applyProperMotion_(raJ2000Deg, decJ2000Deg, pmraMasYr, pmdecMasYr, when);
  return precessJ2000ToDate_(withPM.raDeg, withPM.decDeg, when);
}

/* ======================= HTML DIALOGS & WEB FUNCTIONS ======================= */
/** ---------- API keys: server side ---------- */

const KEY_NAMES = [
  'CSE_KEY',              // Google Custom Search API key
  'CSE_CX',               // Custom Search Engine ID
  'AIRNOW_KEY',
  'EQUIPMENT_API_KEY',
  'ASTROBIN_KEY',
  'LPOLLUTION_KEY'
];

function showApiKeysDialog_() {
  const html = HtmlService.createHtmlOutputFromFile('ApiKeysDialog')
    .setWidth(520)
    .setHeight(600);
  SpreadsheetApp.getUi().showModalDialog(html, 'Set API Keys');
}


function setApiKeysManually() {
  const ui = SpreadsheetApp.getUi();
  
  // Get Google API Key
  const googleKey = ui.prompt('Enter Google Custom Search API Key:', 'Starts with AIzaSy...', ui.ButtonSet.OK_CANCEL);
  if (googleKey.getSelectedButton() !== ui.Button.OK) return;
  
  // Get Google CX
  const googleCx = ui.prompt('Enter Google Custom Search Engine ID:', 'Your search engine ID', ui.ButtonSet.OK_CANCEL);
  if (googleCx.getSelectedButton() !== ui.Button.OK) return;
  
  // Get AirNow Key
  const airNowKey = ui.prompt('Enter AirNow API Key:', 'Your AirNow key (optional)', ui.ButtonSet.OK_CANCEL);
  if (airNowKey.getSelectedButton() !== ui.Button.OK) return;
  
  // Save keys
  const keys = {
    'CSE_KEY': googleKey.getResponseText().trim(),
    'CSE_CX': googleCx.getResponseText().trim(),
    'AIRNOW_KEY': airNowKey.getResponseText().trim()
  };
  
  try {
    PropertiesService.getScriptProperties().setProperties(keys);
    ui.alert('API keys saved successfully!');
  } catch (e) {
    ui.alert('Error saving keys: ' + e.message);
  }
}

function showLocationFinder(context, targetCell) {
    const htmlTemplate = HtmlService.createTemplate(`<!DOCTYPE html><html><head><base target="_top"><meta name="google-apps-script-cando" content="true"><link rel="stylesheet" href="https://ssl.gstatic.com/docs/script/css/add-ons1.css"><style>body{padding:10px;}#results{margin-top:10px;font-weight:bold;}#error{margin-top:10px;color:red;}</style></head><body><input type="hidden" id="context" value="<?= context ?>"><input type="hidden" id="targetCell" value="<?= targetCell ?>"><div class="block"><label for="address">Enter Address or Location:</label><input type="text" id="address" style="width:95%;"></div><div class="block" style="margin-top:10px;"><button class="action" id="findBtn">Find</button><button id="updateBtn" disabled>Update Sheet</button></div><div id="results"></div><div id="error"></div>
    <script>let foundData=null;function updateDisplay(e){document.getElementById("findBtn").disabled=!1,e.error?(document.getElementById("error").textContent=e.error,document.getElementById("updateBtn").disabled=!0,foundData=null):(document.getElementById("error").textContent="",document.getElementById("results").innerHTML="Lat: "+e.lat.toFixed(6)+", Lng: "+e.lng.toFixed(6),document.getElementById("updateBtn").disabled=!1,foundData=e)}document.getElementById("findBtn").addEventListener("click",()=>{document.getElementById("findBtn").disabled=!0,google.script.run.withSuccessHandler(updateDisplay).geocodeAddress(document.getElementById("address").value)}),document.getElementById("updateBtn").addEventListener("click",()=>{foundData&&google.script.run.withSuccessHandler(()=>google.script.host.close()).updateCoordinates(foundData.lat,foundData.lng,foundData.elevation,foundData.timeZone,document.getElementById("context").value,document.getElementById("targetCell").value)});</script></body></html>`);
    htmlTemplate.context = context || 'Setup';  
    htmlTemplate.targetCell = targetCell || '';
    const html = htmlTemplate.evaluate().setWidth(400).setHeight(250);
    SpreadsheetApp.getUi().showModalDialog(html, 'Find Location by Address');
}

function showProgressPie_() {
    const htmlContent = `<!DOCTYPE html><html><head><base target="_top"><meta name="google-apps-script-cando" content="true"><style>body{font-family:Arial,sans-serif;text-align:center;}p{font-size:14px;}#status{font-weight:bold;margin-top:10px;}</style></head><body><p>Processing entries...</p><p id="status">Starting update...</p>
    <script>function updateStatus(e){document.getElementById("status").textContent=e.message,(e.message.startsWith("Successfully")||e.message.startsWith("No new")||e.message.startsWith("Error"))&&setTimeout(()=>google.script.host.close(),2e3)}window.addEventListener("load",()=>google.script.run.withSuccessHandler(updateStatus).withFailureHandler(updateStatus).doObjectUpdate());</script></body></html>`;
    const html = HtmlService.createHtmlOutput(htmlContent).setWidth(300).setHeight(150);
    SpreadsheetApp.getUi().showModalDialog(html, 'Processing Objects...');
}

function getApiKeys_() {
  try {
    const p = PropertiesService.getScriptProperties().getProperties() || {};
    // return only what the dialog expects
    return {
      CSE_KEY:            p.CSE_KEY || '',
      CSE_CX:             p.CSE_CX || '',
      AIRNOW_KEY:         p.AIRNOW_KEY || '',
      EQUIPMENT_API_KEY:  p.EQUIPMENT_API_KEY || '',
      ASTROBIN_KEY:       p.ASTROBIN_KEY || '',
      LPOLLUTION_KEY:     p.LPOLLUTION_KEY || ''
    };
  } catch (e) {
    throw new Error('getApiKeys_ failed: ' + e.message);
  }
}

function setApiKeys_(keys) {
  try {
    const props = PropertiesService.getScriptProperties();
    KEY_NAMES.forEach(name => {
      const v = (keys && name in keys) ? String(keys[name] || '').trim() : '';
      props.setProperty(name, v);
      console.info(`setApiKeys_: ${name} = ${v ? '(set)' : '(empty)'}`);
    });
    return true;
  } catch (e) {
    throw new Error('setApiKeys_ failed: ' + e.message);
  }
}

function testApiConnection() {
  return 'Pong! Connection to the script server is working.';
}

/** Optional: quick editor test to verify saving path */
function testSaveKeys() {
  setApiKeys_({
    CSE_KEY: 'x', CSE_CX: 'y', AIRNOW_KEY: 'z',
    EQUIPMENT_API_KEY: '', ASTROBIN_KEY: '', LPOLLUTION_KEY: ''
  });
  console.info('testSaveKeys: completed');
}
/* ===== API-DLG — START: dialog-friendly key loaders/savers ===== */
function loadApiKeysForDialog() {
  // Return every stored property (safe—values are user-specific to this script)
  return PropertiesService.getScriptProperties().getProperties();
}

function saveApiKeysFromDialog(payload) {
  try {
    // Whitelist only the keys your UI actually supports:
    const allowed = ['CSE_KEY','CSE_CX','AIRNOW_KEY','ASTROBIN_KEY','LPOLLUTION_KEY'];
    const clean = {};
    allowed.forEach(k => {
      if (payload && Object.prototype.hasOwnProperty.call(payload, k)) {
        clean[k] = String(payload[k] || '').trim();
      }
    });
    PropertiesService.getScriptProperties().setProperties(clean, false); // merge, don’t wipe others
    return { ok: true };
  } catch (e) {
    return { ok: false, error: e.message || String(e) };
  }
}
/* ===== API-DLG — END ===== */

function geocodeAddress(address) {
  const { cseKey } = getSkyPixConfig();
  const apiKey = cseKey;
  if (!apiKey || apiKey === 'YOUR_API_KEY_HERE') {
    return { error: 'Google API Key not set in Admin > Set API Keys.' };
  }
  const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${apiKey}`;
  try {
    const response = UrlFetchApp.fetch(url);
    const json = JSON.parse(response.getContentText());
    if (json.status === 'OK') {
      const loc = json.results[0].geometry.location;
      const elevUrl = `https://maps.googleapis.com/maps/api/elevation/json?locations=${loc.lat},${loc.lng}&key=${apiKey}`;
      const tzUrl = `https://maps.googleapis.com/maps/api/timezone/json?location=${loc.lat},${loc.lng}&timestamp=${Math.floor(Date.now() / 1000)}&key=${apiKey}`;
      
      const elevResponse = UrlFetchApp.fetch(elevUrl);
      const elevJson = JSON.parse(elevResponse.getContentText());
      const tzResponse = UrlFetchApp.fetch(tzUrl);
      const tzJson = JSON.parse(tzResponse.getContentText());

      const elevation = (elevJson.status === 'OK') ? elevJson.results[0].elevation : 0;
      const timeZone = (tzJson.status === 'OK') ? tzJson.rawOffset / 3600 : 0;

      return { lat: loc.lat, lng: loc.lng, elevation: elevation, timeZone: timeZone };
    } else {
      return { error: json.error_message || `Geocoding failed: ${json.status}` };
    }
  } catch (e) {
    return { error: e.message };
  }
}

function SkyPix_BuildObjectEntry() { buildObjectEntrySheet_(SpreadsheetApp.getActive()); }
function SkyPix_BuildSetup() { buildSetup_(SpreadsheetApp.getActive()); }
function SkyPix_BuildRigKit() { buildRigKit_(SpreadsheetApp.getActive()); }
function SkyPix_BuildCameraKit() { buildCameraKit_(SpreadsheetApp.getActive()); }
function SkyPix_BuildFilterKit() { buildFilterKit_(SpreadsheetApp.getActive()); }
function SkyPix_BuildObjectDatabase() { buildObjectDatabase_(SpreadsheetApp.getActive()); }

/* ======================= CORE HELPER FUNCTIONS ======================= */
function getHPC_Global_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Setup');
  if (!sh) return DEFAULT_HPC;

  // Find the row by label instead of hard-coding C12
  const row = findRowWithText_(sh, 'Header Primary Color');
  if (!row) return DEFAULT_HPC;

  const cell = sh.getRange(row, 3); // column C
  const val  = String(cell.getDisplayValue() || '').trim();

  // 1) If a named color was selected, map it using your existing COLOR_PICKER
  const hexFromName = nameToHex_(val);     // uses your existing map
  if (hexFromName) return hexFromName;

  // 2) If a literal hex was typed, accept it
  if (/^#?[0-9A-F]{6}$/i.test(val)) return val[0] === '#' ? val : ('#' + val);

  // 3) Else, fall back to the cell background if it’s been painted
  const bg = cell.getBackground();
  if (bg && bg.toLowerCase() !== '#ffffff') return bg;

  return DEFAULT_HPC;
}

function normalizeHexOrName_(s) {
  const t = String(s || '').trim();
  if (/^#[0-9a-f]{6}$/i.test(t)) return t;         // already a hex like #4472c4
  const byName = nameToHex_(t);
  return byName || DEFAULT_HPC;
}

function paintColorCell_(rng, picked) {
  const hex = nameToHex_(picked);
  if (!hex) return;
  rng.setBackground(hex).setValue('').setFontColor(hexIsDark_(hex) ? '#FFFFFF' : '#000000');
}

const styleSubheader_ = (range, fontColor) => {
    return center_(range)
        .setFontSize(HEADER_FS)
        .setFontWeight('bold')
        .setFontColor(fontColor);
};

const nameToHex_ = n => { 
  const hit = COLOR_PICKER.find(r => r[0].toLowerCase() === String(n).toLowerCase()); 
  return hit ? hit[1] : null; 
};

const hexIsDark_ = hex => { 
  const h = String(hex || '').replace('#', ''); 
  if (h.length !== 6) return false; 
  const r = parseInt(h.substr(0, 2), 16), g = parseInt(h.substr(2, 2), 16), b = parseInt(h.substr(4, 2), 16); 
  return (0.299 * r + 0.587 * g + 0.114 * b) < 140; 
};

function hpcShade(hex, pct) { const base = (hex && /^#?[0-9a-f]{6}$/i.test(hex)) ? (hex[0] === '#' ? hex : '#' + hex) : DEFAULT_HPC; const h = base.replace('#', ''); const r = parseInt(h.substr(0, 2), 16), g = parseInt(h.substr(2, 2), 16), b = parseInt(h.substr(4, 2), 16); const t = Math.max(0, Math.min(100, pct)) / 100; const nr = Math.round(255 + (r - 255) * t), ng = Math.round(255 + (g - 255) * t), nb = Math.round(255 + (b - 255) * t); return `#${[nr, ng, nb].map(v => v.toString(16).padStart(2, '0')).join('')}`; }
const center_ = rng => rng.setHorizontalAlignment('center').setVerticalAlignment('middle');
const leftLabel_ = rng => rng.setHorizontalAlignment('left').setVerticalAlignment('middle').setFontSize(LABEL_FS);
const rightLabel_ = rng => rng.setHorizontalAlignment('right').setVerticalAlignment('middle').setFontSize(LABEL_FS);

function stylePaddedCell_(range, text, bgColor, fontColor, isButton = false, leftPadPx = 0) {
  // Approximate pixels per "figure space" at typical 12pt—tweak if needed.
  // Using U+2007 (figure space) is more consistent than normal spaces.
  var pxPerSpace = 3.2;
  var nSpaces = Math.max(0, Math.round(leftPadPx / pxPerSpace));
  var pad = '\u2007'.repeat(nSpaces);

  var fullText = pad + (isButton ? text : text);
  var rtv = SpreadsheetApp.newRichTextValue().setText(fullText);

  // Hide the padding visually by coloring it the same as the background
  // so the text color logic stays clean.
  if (nSpaces > 0) {
    rtv.setTextStyle(0, pad.length,
      SpreadsheetApp.newTextStyle().setForegroundColor(bgColor).build());
  }
  rtv.setTextStyle(pad.length, fullText.length,
      SpreadsheetApp.newTextStyle().setForegroundColor(fontColor).build());

  // Center it (your existing helper)
  center_(range).setRichTextValue(rtv.build());
}


function getPairsFromHeaders_(sh) {
  const out = [];
  let c = 2;
  while (c + 1 <= sh.getMaxColumns()) {
    const hdr = String(sh.getRange(3, c).getDisplayValue() || '').trim();
    if (!hdr) break;
    out.push([c, c + 1]);
    c += 2;
  }
  return out;
}

function getActiveWidth_(sh) {
  const name = sh.getName();
  if (name === 'Setup' || name === 'Object Entry') return sh.getMaxColumns();
  if (name === 'Object Database') return 26;
  
  if (name === FK.NAME) {
    let lastCol = 1;
    let currentCol = 2;
    while (currentCol <= sh.getMaxColumns()) {
      const headerCell = sh.getRange(3, currentCol);
      if (headerCell.getDisplayValue()) {
        const mergedRange = headerCell.getMergedRanges()[0];
        lastCol = mergedRange.getLastColumn();
        currentCol = lastCol + 1;
      } else {
        break;
      }
    }
    return lastCol;
  }
  
  const pairs = getPairsFromHeaders_(sh);
  return pairs.length ? pairs[pairs.length - 1][1] : 3;
}

function mergeFullWidthRow_(sh, row) {
  const width = getActiveWidth_(sh) || sh.getMaxColumns();
  try { sh.getRange(row, 1, 1, sh.getMaxColumns()).breakApart(); } catch (_) { }
  sh.getRange(row, 1, 1, width).merge();
}

function writeRefreshLabel_(sh, bg, options) {
  const range = sh.getRange(2, 1);
  const bgColor = bg || REFRESH_NEUTRAL_BG;
  const choices = options || REFRESH_CHOICES_DEFAULT;

  mergeFullWidthRow_(sh, 2);

  // Use the global padding constant so the label has 10px left padding
  stylePaddedCell_(range, REFRESH_LABEL, bgColor, DARK_GREY_FONT, false, REFRESH_LEFT_PAD_PX);

  range.setFontSize(REFRESH_FS)
       .setFontWeight('bold')
       .setBackground(bgColor);

  const dv = SpreadsheetApp.newDataValidation()
    .requireValueInList(choices, true)
    .setAllowInvalid(true)
    .build();
  range.setDataValidation(dv);
}



// Wrappers now ALWAYS use the two-choice list
const styleRefreshBarNeutral_ = (sh) =>
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, getRefreshChoicesForSheet_(sh));

const setRefreshBarYellow_ = (sh) =>
  writeRefreshLabel_(sh, WARN_YELLOW, getRefreshChoicesForSheet_(sh));


function isValueValid_(value, range) {
  const rule = range.getDataValidation();
  if (!rule) return true;

  const criteria = rule.getCriteriaType();
  const args = rule.getCriteriaValues();

  switch (criteria) {
    case SpreadsheetApp.DataValidationCriteria.NUMBER_BETWEEN:
      return value >= args[0] && value <= args[1];
    case SpreadsheetApp.DataValidationCriteria.NUMBER_GREATER_THAN:
      return value > args[0];
    case SpreadsheetApp.DataValidationCriteria.VALUE_IN_LIST:
      return args[0].indexOf(value) !== -1;
    default:
      return true;
  }
}

/* ---------- Refresh Kits orchestrator ---------- */
// Main orchestrator function - fixed to properly call both Camera Kit and Filter Kit
function refreshKits_() {
  const ss = SpreadsheetApp.getActive();
  const rigSheet = ss.getSheetByName('Rig kit');
  if (!rigSheet) return;

  // Gather rig specs (name, color, focal length) with proper color extraction
  const rigs = _rigkit_getRigSpecs_(rigSheet);

  // Update Camera Kit rig-eligibility with proper HPC shading
  const cameraSheet = ss.getSheetByName('Camera Kit');
  if (cameraSheet) {
    rebuildRigEligibility_Camera_Fixed_(cameraSheet, rigs);
    recolorCameraKitBands_(cameraSheet); // Reapply camera kit colors
  }

  // Update Filter Kit rig-eligibility with proper HPC shading  
  const filterSheet = ss.getSheetByName('Filter Kit');
  if (filterSheet) {
    rebuildRigEligibility_Filter_Fixed_(filterSheet, rigs);
    recolorFilterKitBands_(filterSheet); // Reapply filter kit colors
  }

  SpreadsheetApp.getActive().toast('Camera Kit and Filter Kit refreshed from Rig kit.');
}

/* ---------- Rig kit helpers ---------- */
// Extract rig specifications with proper color handling
function _rigkit_getRigSpecs_(rigSh) {
  const blocks = _rigkit_getBlocks_(rigSh);
  const nameRow = 3;
  const colorRow = findRowWithText_(rigSh, 'Rig highlight color');
  const flRow = findRowWithText_(rigSh, 'Effective focal length'); // (mm)

  const rigs = [];
  blocks.forEach(b => {
    const name = rigSh.getRange(nameRow, b.startCol).getDisplayValue().trim();
    if (!name || /^add rig/i.test(name)) return;
    
    let color = '';
    if (colorRow) {
      // Get the actual background color of the highlight color cell
      const colorCell = rigSh.getRange(colorRow, b.startCol);
      const bgColor = colorCell.getBackground();
      const textValue = colorCell.getDisplayValue().trim();
      
      // Use background color if it's been painted, otherwise try to map the text value
      if (bgColor && bgColor !== '#ffffff' && bgColor !== '#FFFFFF') {
        color = bgColor;
      } else if (textValue) {
        color = nameToHex_(textValue) || textValue;
      }
      
      // Fallback to HPC default if no color found
      if (!color) color = getHPC_Global_();
    }
    
    const fl = flRow ? Number(rigSh.getRange(flRow, b.startCol).getDisplayValue()) : NaN;
    rigs.push({ name, color, focalLengthMM: fl });
  });
  return rigs;
}

// Merge a section header across active rig columns (safe if already merged)
function rigkit_mergeSectionHeader_(sh, headerRow) {
  if (!sh || !headerRow) return;
  const width = Math.max(2, (typeof getActiveWidth_ === 'function' ? getActiveWidth_(sh) : sh.getMaxColumns()));
  try { sh.getRange(headerRow, 1, 1, width).merge(); } catch (e) {}
}

// Find a header row by exact text (returns null if missing)
function findRowWithText_(sh, text) {
  const f = sh.createTextFinder(text).matchEntireCell(true).findNext();
  return f ? f.getRow() : null;
}

function rigkit_forceColorPicker_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Rig kit');
  if (!sh) { ss.toast('Rig kit sheet not found.'); return; }

  // Find the exact label row. If it’s missing, we stop (no fallback).
  const colorRow = findRowWithText_(sh, 'Rig highlight color');
  if (!colorRow) { SpreadsheetApp.getUi().alert('“Rig highlight color” row not found.'); return; }

  // Build dropdown from your existing COLOR_PICKER list (names only).
  const names = COLOR_PICKER.map(r => r[0]);
  const dv = SpreadsheetApp.newDataValidation()
    .requireValueInList(names, true)
    .setAllowInvalid(true)
    .build();

  // Apply to every active rig pair (B/C, D/E, …)
  const pairs = getPairsFromHeaders_(sh); // you already have this helper
  pairs.forEach(([cL/*, cR*/]) => {
    try { sh.getRange(colorRow, cL, 1, 2).breakApart(); } catch(e){}
    sh.getRange(colorRow, cL, 1, 2).merge().setDataValidation(dv);
  });

  ss.toast('Rig color picker restored.');
}

function _rigkit_getBlocks_(sh) {
  const width = getActiveWidth_(sh);
  const blocks = [];
  let c = 2; // rigs start at column B
  while (c <= width) {
    const cell = sh.getRange(3, c);
    const text = cell.getDisplayValue();
    if (text && text.match(/^Rig\s+\d+$/)) {
      const m = cell.getMergedRanges();
      const w = (m && m.length) ? m[0].getWidth() : 2; // Default to 2-column width
      blocks.push({ startCol: c, width: w });
      c += w;
    } else {
      break;
    }
  }
  return blocks;
}

// Show the full Rig-kit refresh list (includes "Refresh Kits")
function rigkit_resetRefreshBar_(sh) {
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_RIG);
}

// What "Refresh Kits" actually does
function refreshKits_() {
  const ss = SpreadsheetApp.getActive();
  // Rebuild camera & filter eligibility from current Rig kit
  rebuildRigEligibility_Camera_();
  rebuildRigEligibility_Filter_();

  // Re-run band coloring / headers so new rigs & colors reflect
  const ck = ss.getSheetByName(CK.NAME);
  if (ck) recolorCameraKitBands_(ck);
  const fk = ss.getSheetByName(FK.NAME);
  if (fk) recolorFilterKitBands_(fk);

  // Optional: ensure the rig color picker keeps working
  if (typeof rigkit_forceColorPicker_ === 'function') {
    rigkit_forceColorPicker_();
  }
  ss.toast('Camera/Filter kits refreshed from Rig kit.');
}

/* ---------- Camera Kit: rig eligibility area ---------- */
function _camerakit_refreshRigEligibility_(camSh, rigs) {
  if (!camSh || !rigs || !rigs.length) return;

  const hpc = getHPC_Global_();
  const border = hpcShade(hpc, 40);
  const width = getActiveWidth_(camSh);

  // Where the “Rig Eligibility” band starts
  const hdr = findRowWithText_(camSh, 'Rig Eligibility');
  if (!hdr) return;
  const startRow = hdr + 1;

  // Discover camera blocks so we can merge a checkbox lane per camera
  const blocks = _camerakit_getBlocks_(camSh);

  // Clear old rows under the header (keep formatting header itself)
  const clearRows = Math.max(1, rigs.length);
  camSh.getRange(startRow, 1, clearRows + 5, Math.max(3, width)).clearContent().removeCheckboxes();

  // Paint header band (keeps your look)
  camSh.getRange(hdr, 1, 1, width)
      .setBackground(hpcShade(hpc, 30))
      .setBorder(true, true, true, true, true, true, border, SpreadsheetApp.BorderStyle.SOLID);

  // Write each rig label in column A and create a merged checkbox lane per camera
  rigs.forEach((rig, i) => {
    const row = startRow + i;
    const hex = nameToHex_(rig.color) || rig.color || '';
    const txtCell = camSh.getRange(row, 1).setValue(rig.name);
    if (hex) {
      const font = hexIsDark_(hex) ? '#FFFFFF' : '#000000';
      camSh.getRange(row, 1, 1, width).setBackground(hex).setFontColor(font);
    }
    // a checkbox “lane” per camera block
    blocks.forEach(b => {
      const r = camSh.getRange(row, b.startCol, 1, b.width).merge();
      r.insertCheckboxes().setHorizontalAlignment('center').setBorder(null, true, null, true, null, null, border, SpreadsheetApp.BorderStyle.SOLID);
    });
  });
}

// 1. Fix Row 32 validation to accept decimals (not just integers)
function rigkit_fixRow32Validation_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  
  const pairs = getPairsFromHeaders_(sh);
  pairs.forEach(([cL]) => {
    // Allow Bortle (1.0-9.0) OR magnitude (14.0-25.0) as decimals
    const dv = SpreadsheetApp.newDataValidation()
      .requireNumberBetween(1.0, 25.0)
      .setAllowInvalid(true)
      .setHelpText('Enter Bortle class (1-9) or sky brightness (14-25 mag/arcsec²)')
      .build();
    
    sh.getRange(32, cL, 1, 2).setDataValidation(dv);
    
    // Check if current value is invalid and paint yellow if so
    const val = sh.getRange(32, cL, 1, 2).getValue();
    if (val && (val < 1 || (val > 9 && val < 14) || val > 25)) {
      sh.getRange(32, cL, 1, 2).setBackground(WARN_YELLOW);
    }
  });
}

// 2. Fix Acknowledge Defaults to unpaint ALL orange cells when checked
function rigkit_fixAcknowledgeDefaults_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  
  const pairs = getPairsFromHeaders_(sh);
  
  pairs.forEach(([cL, cR]) => {
    const ackCell = sh.getRange(15, cL, 1, 2);
    const isChecked = ackCell.getValue();
    
    if (isChecked === true) {
      // Define all data rows that should be unpainted
      const dataRowRanges = [
        [4, 6],   // Rig model through central obstruction
        [8, 14],  // Focal length through DST end
        [16, 16], // Color picker
        [19, 24], // Display content
        [27, 33], // Imaging constraints
        [36, 38], // Zenith obstruction
        [41, 50]  // Landscape horizon
      ];
      
      // Clear orange from all these ranges
      dataRowRanges.forEach(([startRow, endRow]) => {
        for (let r = startRow; r <= endRow; r++) {
          const range = sh.getRange(r, cL, 1, 2);
          const bg = range.getBackground();
          if (bg && bg.toLowerCase() === WARN_ORANGE.toLowerCase()) {
            range.setBackground(null);
          }
        }
      });
    }
  });
}

// 3. Fix color picker to paint the cell immediately when color is chosen
function rigkit_fixColorPicker_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  
  const pairs = getPairsFromHeaders_(sh);
  
  pairs.forEach(([cL]) => {
    const colorCell = sh.getRange(16, cL, 1, 2);
    const colorName = String(colorCell.getDisplayValue() || '').trim();
    
    if (colorName) {
      const hex = nameToHex_(colorName);
      if (hex) {
        colorCell.setBackground(hex)
                 .setValue('') // Clear the text after painting
                 .setFontColor(hexIsDark_(hex) ? '#FFFFFF' : '#000000');
      }
    }
  });
}

// 4. Paint validation failures yellow
function rigkit_paintValidationFailures_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  
  const pairs = getPairsFromHeaders_(sh);
  
  pairs.forEach(([cL, cR]) => {
    // Check all validated cells
    const validatedRanges = [
      { row: 5, min: 10, max: 2000 },      // Aperture
      { row: 6, min: 0, max: 200 },        // Central obstruction
      { row: 8, min: 50, max: 10000 },     // Focal length
      { row: 9, min: -90, max: 90 },       // Latitude
      { row: 10, min: -180, max: 180 },    // Longitude
      { row: 11, min: -100, max: 5000 },   // Elevation
      { row: 12, min: -12, max: 12 },      // UTC
      { row: 22, min: 1, max: 12 },        // Observable months
      { row: 23, min: 10, max: 480 },      // Min observable time
      { row: 27, min: 0, max: 9999 },      // Max integration time
      { row: 28, min: 0, max: 999 },       // Max subframe exposure
      { row: 29, min: 0, max: 80 },        // Min elevation
      { row: 30, min: 0, max: 90 },        // Lunar avoidance
      { row: 31, min: -50, max: 50 },      // Ambient temp
      { row: 32, min: 1, max: 25 },        // Sky brightness (special case)
      { row: 33, min: 0, max: 200 }        // Air quality
    ];
    
    validatedRanges.forEach(({ row, min, max }) => {
      const cell = sh.getRange(row, cL, 1, 2);
      const val = cell.getValue();
      
      // Special handling for row 32 (gap between 9 and 14)
      if (row === 32 && val) {
        if (val < 1 || (val > 9 && val < 14) || val > 25) {
          cell.setBackground(WARN_YELLOW);
        }
      } else if (val && (val < min || val > max)) {
        cell.setBackground(WARN_YELLOW);
      }
    });
    
    // Check row 24 separately (not merged, two cells)
    const leftVal = sh.getRange(24, cL).getValue();
    const rightVal = sh.getRange(24, cR).getValue();
    if (leftVal && (leftVal < -90 || leftVal > 90)) {
      sh.getRange(24, cL).setBackground(WARN_YELLOW);
    }
    if (rightVal && (rightVal < -90 || rightVal > 90)) {
      sh.getRange(24, cR).setBackground(WARN_YELLOW);
    }
  });
}

// 5. Paint blank cells and helper text cells yellow
function rigkit_paintBlanksYellow_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  
  const pairs = getPairsFromHeaders_(sh);
  
  pairs.forEach(([cL, cR]) => {
    // Rows 5-12 (skip row 7 - calculated field)
    for (let row = 5; row <= 12; row++) {
      if (row === 7) continue; // Skip calculated effective aperture area
      
      const cell = sh.getRange(row, cL, 1, 2);
      const val = String(cell.getDisplayValue() || '').trim();
      
      if (!val) {
        cell.setBackground(WARN_YELLOW);
      }
    }
    
    // Rows 19-24 (row 24 is NOT merged, handle separately)
    for (let row = 19; row <= 23; row++) {
      const cell = sh.getRange(row, cL, 1, 2);
      const val = String(cell.getDisplayValue() || '').trim();
      
      if (!val) {
        cell.setBackground(WARN_YELLOW);
      }
    }
    
    // Row 24 special handling (two separate cells)
    const left24 = sh.getRange(24, cL);
    const right24 = sh.getRange(24, cR);
    const leftVal = String(left24.getDisplayValue() || '').trim();
    const rightVal = String(right24.getDisplayValue() || '').trim();
    
    if (!leftVal || leftVal === '> Dec') {
      left24.setBackground(WARN_YELLOW);
    }
    if (!rightVal || rightVal === '< Dec') {
      right24.setBackground(WARN_YELLOW);
    }
    
    // Rows 41-44 (Landscape Horizon - check for blanks or "Az"/"Alt" helpers)
    for (let row = 41; row <= 44; row++) {
      const azCell = sh.getRange(row, cL);
      const altCell = sh.getRange(row, cR);
      
      const azVal = String(azCell.getDisplayValue() || '').trim();
      const altVal = String(altCell.getDisplayValue() || '').trim();
      
      // Paint yellow if blank OR still showing helper text
      if (!azVal || azVal === 'Az') {
        azCell.setBackground(WARN_YELLOW);
      }
      if (!altVal || altVal === 'Alt') {
        altCell.setBackground(WARN_YELLOW);
      }
    }
  });
}

// 6. Ensure rows 22-23 are horizontally merged
function rigkit_mergeRows2223_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  
  const pairs = getPairsFromHeaders_(sh);
  
  pairs.forEach(([cL, cR]) => {
    try {
      sh.getRange(22, cL, 1, 2).merge();
      sh.getRange(23, cL, 1, 2).merge();
    } catch (e) {
      // Already merged or merge failed
    }
  });
}

function DEBUG_CheckRigPairs() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  const pairs = getPairsFromHeaders_(sh);
  
  Logger.log('Number of rig pairs found: ' + pairs.length);
  pairs.forEach(([cL, cR], i) => {
    Logger.log(`Rig ${i+1}: columns ${cL}-${cR}`);
    Logger.log(`  Header: ${sh.getRange(3, cL).getDisplayValue()}`);
  });
}

function SkyPix_FixRigKitValidation() {
  rigkit_fixRow32Validation_();
  rigkit_fixAcknowledgeDefaults_();
  rigkit_fixColorPicker_();
  rigkit_paintValidationFailures_();
  rigkit_paintBlanksYellow_();
  rigkit_mergeRows2223_();
  
  SpreadsheetApp.getActive().toast('All Rig Kit validation fixes applied.');
}

// Helper function to get camera blocks (similar to your existing camera block detection)
function _camerakit_getBlocks_(sh) {
  const width = getActiveWidth_(sh);
  const blocks = [];
  let c = 2; // cameras start at column B
  while (c <= width) {
    const cell = sh.getRange(3, c);
    const label = cell.getDisplayValue().trim();
    if (label && label.match(/^Camera\s+\d+$/)) {
      const m = cell.getMergedRanges();
      const w = (m && m.length) ? m[0].getWidth() : 2; // Default camera width
      blocks.push({ startCol: c, width: w });
      c += w;
    } else {
      break;
    }
  }
  return blocks;
}

function rebuildRigEligibility_Camera_Fixed_(camSh, rigs) {
  if (!camSh || !rigs || !rigs.length) return;

  const hpc = getHPC_Global_();
  const width = getActiveWidth_(camSh);
  
  // Find the Rig Eligibility header
  let eligHeader = findRowWithText_(camSh, 'Rig Eligibility');
  if (!eligHeader) {
    // Create Rig Eligibility section if it doesn't exist
    const lastDataRow = Math.max(15, camSh.getLastRow());
    camSh.insertRowsAfter(lastDataRow, 1);
    eligHeader = lastDataRow + 1;
    mergeFullWidthRow_(camSh, eligHeader);
    camSh.getRange(eligHeader, 1).setValue('Rig Eligibility')
          .setBackground(hpcShade(hpc, 40))
          .setFontSize(12)
          .setFontWeight('bold')
          .setFontColor(DARK_GREY_FONT)
          .setHorizontalAlignment('center')
          .setVerticalAlignment('middle');
  }

  const startRow = eligHeader + 1;
  
  // Clear existing rig eligibility rows (generous clear)
  const clearRows = Math.max(rigs.length * 3, 20);
  if (startRow + clearRows <= camSh.getMaxRows()) {
    camSh.getRange(startRow, 1, clearRows, width)
        .clearContent()
        .removeCheckboxes()
        .setBackground(null)
        .setFontWeight('normal')
        .setFontColor('#000000');
  }

  // Get camera blocks for proper merging
  const cameraBlocks = _camerakit_getBlocks_(camSh);

  // Build rig triplets with proper HPC shading
  rigs.forEach((rig, i) => {
    const tripletStart = startRow + (i * 3);
    const checkboxRow = tripletStart;
    const fovRow = tripletStart + 1;
    const scaleRow = tripletStart + 2;
    
    // Get rig color and apply HPC shading (lighter shade for readability)
    const rigColor = rig.color || hpc;
    const shadedColor = hpcShade(rigColor, 60); // Lighter shade for better readability
    const fontColor = hexIsDark_(shadedColor) ? '#FFFFFF' : '#000000';

    // Apply rig name and color to all three rows
    camSh.getRange(checkboxRow, 1).setValue(rig.name).setFontWeight('normal');
    camSh.getRange(fovRow, 1).setValue('Field of View (arcminutes)').setFontWeight('normal');
    camSh.getRange(scaleRow, 1).setValue('Image Scale (arcsec/pixel)').setFontWeight('normal');
    
    // Apply HPC-shaded background to entire triplet across all columns
    camSh.getRange(checkboxRow, 1, 3, width)
        .setBackground(shadedColor)
        .setFontColor(fontColor);

    // Set up camera-specific cells for each camera block
    cameraBlocks.forEach(block => {
      // Checkbox row - merged across camera block
      camSh.getRange(checkboxRow, block.startCol, 1, block.width)
          .merge()
          .insertCheckboxes()
          .setHorizontalAlignment('center')
          .setVerticalAlignment('middle');

      // FOV and Scale rows - merged across camera block  
      camSh.getRange(fovRow, block.startCol, 1, block.width)
          .merge()
          .setValue('0')
          .setHorizontalAlignment('center')
          .setVerticalAlignment('middle');
          
      camSh.getRange(scaleRow, block.startCol, 1, block.width)
          .merge()
          .setValue('0')
          .setHorizontalAlignment('center')
          .setVerticalAlignment('middle');
    });
  });
}

// Fixed Filter Kit rig eligibility rebuild with proper HPC color shading
function rebuildRigEligibility_Filter_Fixed_(filterSh, rigs) {
  if (!filterSh || !rigs || !rigs.length) return;

  const hpc = getHPC_Global_();
  const width = getActiveWidth_(filterSh);
  
  // Find the Rig Eligibility header
  let eligHeader = findRowWithText_(filterSh, 'Rig Eligibility');
  if (!eligHeader) {
    // If no Rig Eligibility section exists, we need to rebuild the entire layout
    // This should normally be handled by rebuildFilterKitLayout_(), but we'll ensure it exists
    const ackRow = findRowWithText_(filterSh, 'Acknowledge Defaults');
    if (ackRow) {
      filterSh.insertRowsAfter(ackRow, 2);
      eligHeader = ackRow + 2;
      mergeFullWidthRow_(filterSh, eligHeader);
      filterSh.getRange(eligHeader, 1).setValue('Rig Eligibility')
              .setBackground(hpcShade(hpc, 40))
              .setFontSize(12)
              .setFontWeight('bold')
              .setFontColor(DARK_GREY_FONT)
              .setHorizontalAlignment('center')
              .setVerticalAlignment('middle');
    }
  }

  if (!eligHeader) return; // Safety check

  const startRow = eligHeader + 1;
  
  // Clear existing rig rows
  const clearRows = Math.max(rigs.length + 5, 10);
  if (startRow + clearRows <= filterSh.getMaxRows()) {
    filterSh.getRange(startRow, 1, clearRows, width)
            .clearContent()
            .removeCheckboxes()
            .setBackground(null)
            .setFontWeight('normal')
            .setFontColor('#000000');
  }

  // Get filter blocks for proper merging
  const filterBlocks = getFilterBlocks_(filterSh);

  // Add each rig as a row with proper HPC shading
  rigs.forEach((rig, i) => {
    const row = startRow + i;
    
    // Get rig color and apply HPC shading
    const rigColor = rig.color || hpc;
    const shadedColor = hpcShade(rigColor, 60); // Lighter shade for better readability
    const fontColor = hexIsDark_(shadedColor) ? '#FFFFFF' : '#000000';

    // Set rig name and apply color across entire row
    leftLabel_(filterSh.getRange(row, 1)).setValue(rig.name);
    filterSh.getRange(row, 1, 1, width)
            .setBackground(shadedColor)
            .setFontColor(fontColor);

    // Add checkbox for each filter block
    filterBlocks.forEach(block => {
      filterSh.getRange(row, block.startCol, 1, block.width)
              .merge()
              .insertCheckboxes()
              .setHorizontalAlignment('center')
              .setVerticalAlignment('middle');
    });
  });
}

/* ======================= SHEET BUILDERS & MODULES ======================= */

// --- Setup Module ---
function buildSetup_(ss) {
  const sh = ss.getSheetByName('Setup') || ss.insertSheet('Setup', 1);
  sh.clear(); sh.setName('Setup');
  while (sh.getMaxColumns() > 3) sh.deleteColumn(4);
  sh.setColumnWidths(1, 3, 120).setRowHeights(1, sh.getMaxRows(), ROW_H_ALL);

  // Merge A2:C2, set neutral grey, no text, no dropdown
  sh.getRange('A2:C2').merge();
  sh.getRange('A2').setValue('');
  sh.getRange('A2').clearDataValidations();
  sh.getRange('A2').clearNote();
  sh.getRange('A2').setBackground(REFRESH_NEUTRAL_BG);

  // Set C4 with line wrapping
  sh.getRange('C4').setWrap(true);

  // Perform all row insertions first to establish the final layout
  sh.insertRows(10, 1); // Spacer before Display Colors
  sh.insertRows(16, 1); // Spacer before Batch Processing

  // Merge all full-width rows
  mergeFullWidthRow_(sh, 1);
  mergeFullWidthRow_(sh, 10);
  mergeFullWidthRow_(sh, 16);

  // Set all section titles
  sh.getRange('A1').setValue('Setup');
  sh.getRange('A3').setValue('Home Site Location');
  sh.getRange('A11').setValue('Display Colors');
  sh.getRange('A17').setValue('Batch Processing');
  sh.getRange('A3').setNote('Docs placeholder: how to set home site lat/lon/UTC/elevation.');
  sh.getRange('A11').setNote('Docs placeholder: how header/observability/warning colors are used.');
  sh.getRange('A17').setNote('Docs placeholder: how batch size & auto-continue work.');

  // Home Site Location section (Bortle removed)
  const home = ['Latitude (°) [N + / S -]', 'Longitude (°) [E + / W -]', 'UTC Offset (hrs)', 'Elevation (m)', 'DST Start (MM-DD-YY)', 'DST End (MM-DD-YY)'];
  home.forEach((t, i) => leftLabel_(sh.getRange(4 + i, 1, 1, 2).merge()).setValue(t).setWrap(true));
  
  const dvNum = (a, b) => SpreadsheetApp.newDataValidation().requireNumberBetween(a, b).setAllowInvalid(true).build();
  
  // Set up the Location Finder dropdown in C4
  setSetupLocationFinderDropdown_(sh);

  // Clear initial values and paint yellow for user input
  sh.getRange('C4:C7').clearContent();
  sh.getRange('C4:C9').setBackground(WARN_YELLOW);

  sh.getRange('C8:C9').setNumberFormat('MM-dd-yy').setDataValidation(SpreadsheetApp.newDataValidation().requireDate().setAllowInvalid(true).build());
  
  // Display Colors section
  leftLabel_(sh.getRange('A12:B12').merge()).setValue('Header Primary Color');
  leftLabel_(sh.getRange('A13:B13').merge()).setValue('Observability Primary Color'); // A13/B13
  leftLabel_(sh.getRange('A14:B14').merge()).setValue('Warning Color');
  leftLabel_(sh.getRange('A15:B15').merge()).setValue('Attention Color');

  const picker = SpreadsheetApp.newDataValidation().requireValueInList(COLOR_PICKER.map(r=>r[0]),true).setAllowInvalid(true).build();
  sh.getRange('C12:C13').setDataValidation(picker);
  paintColorCell_(sh.getRange('C12'), 'Blue');
  paintColorCell_(sh.getRange('C13'), 'Green');
  sh.getRange('C14').setBackground(WARN_YELLOW).setValue('');
  sh.getRange('C15').setBackground(WARN_ORANGE).setValue('');

  // Batch Processing section (row numbers corrected)
  leftLabel_(sh.getRange('A18:B18').merge()).setValue('Objects per batch');
  sh.getRange('C18').setValue(25).setBackground(WARN_ORANGE);
  leftLabel_(sh.getRange('A19:B19').merge()).setValue('Auto-continue batches');
  sh.getRange('C19').setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(['TRUE','FALSE'],true).build()).setValue('TRUE').setBackground(WARN_ORANGE);
  leftLabel_(sh.getRange('A20:B20').merge()).setValue('# of Astrobin images to review');
  sh.getRange('C20').setValue(8).setDataValidation(dvNum(1, 25)).setBackground(WARN_ORANGE);
  
  // Acknowledge Defaults section (row number corrected)
  leftLabel_(sh.getRange('A21:B21').merge()).setValue('Acknowledge Defaults');
  sh.getRange('C21').insertCheckboxes();

  // Center all data cells (ranges corrected)
  center_(sh.getRange('C4:C9'));
  center_(sh.getRange('C12:C15'));
  center_(sh.getRange('C18:C21'));

  recolorSetupSheet_(sh);

  // Added missing call to create the refresh bar
  // styleRefreshBarNeutral_(sh);
  enforceSetupFormats_(sh); // <— add this line
  sh.setFrozenRows(2);

  sh.setFrozenRows(2);
}

function recolorSetupSheet_(sh) {
  if (!sh) return;
  const hpc = getHPC_Global_();
  const width = getActiveWidth_(sh);

  const title = sh.getRange(1, 1, 1, width).merge();
  styleSubheader_(title, '#FFFFFF');
  title.setBackground(hpcShade(hpc, 80)).setFontSize(TITLE_FS);

  const subheaderRows = [3, 11, 17]; 
  subheaderRows.forEach(row => {
      const subheaderRange = sh.getRange(row, 1, 1, width).merge();
      subheaderRange.setBackground(hpcShade(hpc, 40));
      styleSubheader_(subheaderRange, DARK_GREY_FONT);
  });
}

// --- Object Entry Module ---
function buildObjectEntrySheet_(ss) {
    const sh = ss.getSheetByName('Object Entry') || ss.insertSheet('Object Entry', 0);
    sh.clear(); sh.setName('Object Entry');
    while(sh.getMaxColumns() > 7) sh.deleteColumn(8);

    sh.setColumnWidth(1, 80);
    sh.setColumnWidth(2, 150);
    sh.setColumnWidth(3, 70);  // RA
    sh.setColumnWidth(4, 70);  // Dec
    sh.setColumnWidth(5, 50);
    sh.setColumnWidth(6, 50);
    sh.setColumnWidth(7, 60);

    // Make RA/Dec 10pt, no wrap
    sh.getRange('C:C').setFontSize(10).setWrap(false);
    sh.getRange('D:D').setFontSize(10).setWrap(false);

    // Title + header notes (placeholder docs + status explainer)
    sh.getRange('A1').setNote(
      'SkyPix Object Entry — documentation placeholder.\n' +
      'Paste IDs into column A (row 5+) to resolve and stage objects before refresh.'
    );
    sh.getRange('G3:G4').setNote(
      'Status values:\n' +
      '• Searching… — resolving object\n' +
      '• Success — ready for database\n' +
      '• Duplicate (Entry) — same ID/name exists in Object Entry\n' +
      '• Duplicate — already in Object Database\n' +
      '• Not Found — no match in SIMBAD\n' +
      '• Error — lookup error; see cell note'
    );

    sh.setRowHeights(1, 2, 36).setRowHeights(3, 2, 25);

    center_(sh.getRange('A1:G1').merge()).setValue('Object Entry').setFontWeight('bold').setFontSize(TITLE_FS);
    styleRefreshBarNeutral_(sh);
    
    sh.getRange('A3:A4').mergeVertically();
    sh.getRange('B3:B4').mergeVertically();
    sh.getRange('C3:C4').mergeVertically();
    sh.getRange('D3:D4').mergeVertically();
    sh.getRange('G3:G4').mergeVertically();
    sh.getRange('E3:F3').merge();

    const formatHeaderLabel = (range, label) => center_(range).setVerticalAlignment('bottom').setFontWeight('bold').setFontSize(10).setValue(label).setFontColor('#434343');
    formatHeaderLabel(sh.getRange('A3'), 'Object ID');
    formatHeaderLabel(sh.getRange('B3'), 'Object Name');
    formatHeaderLabel(sh.getRange('C3'), 'RA');
    formatHeaderLabel(sh.getRange('D3'), 'Dec');
    formatHeaderLabel(sh.getRange('E3'), 'Size (arcmin)');
    formatHeaderLabel(sh.getRange('E4'), 'Width');
    formatHeaderLabel(sh.getRange('F4'), 'Height');
    formatHeaderLabel(sh.getRange('G3'), 'Status');
    
    sh.getRange('A3:G4').setBorder(true, true, true, true, true, true, hpcShade(getHPC_Global_(), 40), SpreadsheetApp.BorderStyle.SOLID);
    sh.getRange('A5:G').setHorizontalAlignment('center').setVerticalAlignment('middle').setWrap(true);
    sh.setRowHeights(5, sh.getMaxRows() - 4, ROW_H_ALL);
    sh.setFrozenRows(4);
    recolorObjectEntrySheet_(sh);
}

function recolorObjectEntrySheet_(sh) {
    if (!sh) return;
    const hpc = getHPC_Global_();
    sh.getRange('A1').setBackground(hpcShade(hpc, 80)).setFontColor('#FFFFFF');
    sh.getRange('A3:G4').setBackground(hpcShade(hpc, 20));
}

/* ===== SIMBAD RESOLVER — helpers ===== */

function _degToHMS(deg) {
  // deg RA (0..360) → "HH:MM:SS"
  const totalSec = (deg / 15) * 3600;
  const h = Math.floor(totalSec / 3600);
  const m = Math.floor((totalSec % 3600) / 60);
  const s = Math.round(totalSec % 60);
  return [h, m, s].map(n => String(n).padStart(2, '0')).join(':');
}
function _degToDMS(deg) {
  // deg Dec (-90..+90) → "±DD:MM:SS"
  const sign = deg < 0 ? '-' : '+';
  const a = Math.abs(deg);
  const d = Math.floor(a);
  const mFloat = (a - d) * 60;
  const m = Math.floor(mFloat);
  const s = Math.round((mFloat - m) * 60);
  return sign + [d, m, s].map(n => String(n).padStart(2, '0')).join(':');
}

// Normalize inputs so SIMBAD matches: "M68" → "M 68", "NGC2841" → "NGC 2841"
function _canonObjectId_(s){
  const t = String(s||'').trim().toUpperCase();
  const m = t.match(/^M\s*0*([1-9]\d*)$/);     if (m)  return 'M '   + m[1];
  const n = t.match(/^NGC\s*0*([1-9]\d*)$/);   if (n)  return 'NGC ' + n[1];
  const ic= t.match(/^IC\s*0*([1-9]\d*)$/);    if (ic) return 'IC '  + ic[1];
  return String(s||'').trim();
}

// Split a resolved name into catalog (e.g. "M 42") and common name (e.g. "Orion Nebula")
// If not split-able, returns catalog as main_id and common as empty string.
function _splitResolvedName_(main_id) {
  // Example main_id: "M 42 (Orion Nebula)"
  const m = String(main_id || '').match(/^(.+?)\s*\((.+?)\)$/);
  if (m) {
    return { catalog: m[1].trim(), common: m[2].trim() };
  }
  // If no parentheses, try to split by comma
  const parts = String(main_id || '').split(',');
  if (parts.length > 1) {
    return { catalog: parts[0].trim(), common: parts.slice(1).join(',').trim() };
  }
  return { catalog: String(main_id || '').trim(), common: '' };
}

// SESAME fallback (very forgiving)
function SkyPix_SESAME_(ident){
  const url  = 'https://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oI/A?' + encodeURIComponent(ident);
  const resp = UrlFetchApp.fetch(url, { muteHttpExceptions:true });
  if (resp.getResponseCode() !== 200) return null;
  const txt  = resp.getContentText();
  const jpos = txt.match(/#JPOS\s*=\s*([0-9.+-]+)\s+([0-9.+-]+)/);
  if (!jpos) return null;
  const jname= txt.match(/%J,NAME\s*=\s*(.*)/);
  return {
    main_id: (jname && jname[1] && jname[1].trim()) || ident,
    raDeg: parseFloat(jpos[1]),
    decDeg: parseFloat(jpos[2]),
  };
}


/* ===== DB-DUPS-0 — START: DB duplicate helpers ===== */
function _normId_(s){ return String(s || '').trim().toLowerCase(); }

function getObjectDatabaseIndex_(){
  const sh = SpreadsheetApp.getActive().getSheetByName('Object Database');
  if (!sh) return { ids:new Set(), names:new Set() };
  const first = 5, last = sh.getLastRow();
  const n = Math.max(0, last - first + 1);
  if (n <= 0) return { ids:new Set(), names:new Set() };

  const ids   = sh.getRange(first, 1, n, 1).getDisplayValues().flat().map(_normId_).filter(Boolean);
  const names = sh.getRange(first, 2, n, 1).getDisplayValues().flat().map(_normId_).filter(Boolean);
  return { ids:new Set(ids), names:new Set(names) };
}

function isDuplicateObject_(objectId, mainName){
  const { ids, names } = getObjectDatabaseIndex_();
  const idn = _normId_(objectId);
  const nn  = _normId_(mainName);
  if (idn && ids.has(idn))   return { dup:true, where:'Object ID',   match:objectId };
  if (nn  && names.has(nn))  return { dup:true, where:'Object Name', match:mainName };
  return { dup:false };
}
/* ===== DB-DUPS-0 — END ===== */

/* ===== DB-DUPS-1 — START: in-sheet duplicate detector ===== */
function isDuplicateInEntrySheet_(entrySheet, currentRow, objectId, mainName){
  const first = 5, last = entrySheet.getLastRow();
  if (last < first) return null;
  const ids   = entrySheet.getRange(first, 1, last-first+1, 1).getDisplayValues().flat();
  const names = entrySheet.getRange(first, 2, last-first+1, 1).getDisplayValues().flat();
  const idn = _normId_(objectId);
  const nn  = _normId_(mainName);

  for (let i = 0; i < ids.length; i++){
    const r = first + i;
    if (r === currentRow) continue;
    if (idn && idn === _normId_(ids[i]))   return `Duplicate in Object Entry by Object ID at row ${r}`;
    if (nn  && nn  === _normId_(names[i])) return `Duplicate in Object Entry by Object Name at row ${r}`;
  }
  return null;
}
/* ===== DB-DUPS-1 — END ===== */

/** --------- Tiny HTTP helper with logging --------- */
function _httpFetchText_(url){
  const resp = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
  const code = resp.getResponseCode();
  const text = resp.getContentText();
  Logger.log(`[HTTP] ${code} ${url}\n${text.slice(0, 400)}...`);
  return { code, text };
}

/** --------- SIMBAD TAP via ident→basic join (best for “M 68” etc.) --------- */
function SkyPix_TAP_ByIdent_(ident){
  const adql =
    `SELECT TOP 1 b.main_id, b.ra, b.dec, b.pmra, b.pmdec
     FROM ident AS i JOIN basic AS b ON b.oid = i.oidref
     WHERE i.id='${String(ident).replace(/'/g,"''")}'`;
  const url = 'https://simbad.u-strasbg.fr/simbad/sim-tap/sync'
            + '?request=doQuery&lang=adql&format=tsv&query=' + encodeURIComponent(adql);
  const r = UrlFetchApp.fetch(url, { muteHttpExceptions:true });
  if (r.getResponseCode() !== 200) return null;
  const lines = (r.getContentText()||'').trim().split(/\r?\n/);
  if (lines.length < 2) return null;
  const c = lines[1].split('\t');
  const raDeg  = parseFloat(c[1]), decDeg = parseFloat(c[2]);
  if (isNaN(raDeg) || isNaN(decDeg)) return null;
  const pmra  = c[3] === '' ? 0 : parseFloat(c[3]);
  const pmdec = c[4] === '' ? 0 : parseFloat(c[4]);
  return { main_id: c[0] || ident, raDeg, decDeg, pmra, pmdec };
}

/** --------- SIMBAD simple endpoint (secondary try) --------- */
function SkyPix_SIMBAD_Simple_(ident){
  const url = 'https://simbad.u-strasbg.fr/simbad/sim-id?Ident='
            + encodeURIComponent(ident) + '&output.format=ASCII';
  const { code, text } = _httpFetchText_(url);
  if (code !== 200) return null;
  // crude pulls for “Coordinates (J2000)” lines
  const raM = text.match(/RA\s*:\s*([0-9.]+)\s*deg/i);
  const deM = text.match(/DEC\s*:\s*([+\-0-9.]+)\s*deg/i);
  const nmM = text.match(/Main identifier\s*:\s*(.+)/i);
  if (!raM || !deM) return null;
  return {
    main_id: (nmM && nmM[1].trim()) || ident,
    raDeg: parseFloat(raM[1]),
    decDeg: parseFloat(deM[1])
  };
}

/** --------- SESAME fallback (very forgiving) --------- */
function SkyPix_SESAME_(ident){
  const url  = 'https://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oI/A?' + encodeURIComponent(ident);
  const { code, text } = _httpFetchText_(url);
  if (code !== 200) return null;
  const jpos = text.match(/#JPOS\s*=\s*([0-9.+-]+)\s+([0-9.+-]+)/);
  if (!jpos) return null;
  const jname= text.match(/%J,NAME\s*=\s*(.*)/);
  return {
    main_id: (jname && jname[1] && jname[1].trim()) || ident,
    raDeg: parseFloat(jpos[1]),
    decDeg: parseFloat(jpos[2])
  };
}

/** --------- Guaranteed “don’t block me” fallback for a few Ms --------- */
const SKYPIX_MESSIER_FALLBACK = {
  'M 42':  { main_id:'M 42 (Orion Nebula)',         raDeg:83.8221,  decDeg:-5.3911,  maj:85,  min:60 },
  'M 3':   { main_id:'M 3 (NGC 5272)',              raDeg:205.5484, decDeg:28.3776,  maj:18,  min:18 },
  'M 68':  { main_id:'M 68 (NGC 4590)',             raDeg:189.8667, decDeg:-26.7447, maj:11,  min:11 },
  'M 101': { main_id:'M 101 (Pinwheel Galaxy)',     raDeg:210.8023, decDeg:54.3489,  maj:28.8,min:26.9 }
};

/** --------- Main: replace your current fetchSimbadData with this --------- */

function fetchSimbadData(cell){
  const sh  = cell.getSheet();
  const row = cell.getRow();
  const idRaw = _cleanCatalogId_(cell.getDisplayValue());

  const nameCell = sh.getRange(row, 2);
  const raCell   = sh.getRange(row, 3);
  const decCell  = sh.getRange(row, 4);
  const wCell    = sh.getRange(row, 5);
  const hCell    = sh.getRange(row, 6);
  const status   = sh.getRange(row, 7);

  // clear prior content/notes; show searching
  [nameCell, raCell, decCell, wCell, hCell, status].forEach(c => { c.clearNote(); });
  [nameCell, raCell, decCell, wCell, hCell].forEach(c => c.clearContent());
  status.setValue('Searching…');

  SpreadsheetApp.flush();

  try {
    // Try variants
    const tries = _genCandidates_(idRaw);
    let hit = null;
    let fallback = null;
    for (const ident of tries){
      fallback = SKYPIX_MESSIER_FALLBACK[ident];
      hit = SkyPix_TAP_ByIdent_(ident);
      if (!hit) hit = SkyPix_SIMBAD_Simple_(ident);
      if (!hit && fallback) hit = fallback;
      if (hit) break;
    }
    if (!hit){ status.setValue('Not Found'); _centerEntryRow_(sh, row); return 'Not Found'; }

    // Use fallback for name/size if available
    if (fallback) {
      // Use fallback main_id, size if missing
      if (!hit.main_id || hit.main_id === idRaw) hit.main_id = fallback.main_id;
      if (!('maj' in hit) && 'maj' in fallback) hit.maj = fallback.maj;
      if (!('min' in hit) && 'min' in fallback) hit.min = fallback.min;
    }

    // split catalog/common for display
    const nm = _splitResolvedName_(hit.main_id || idRaw);

    // Write values
    nameCell.setValue(nm.common || nm.catalog || idRaw);
    raCell.setValue(_degToHMS(hit.raDeg));
    decCell.setValue(_degToDMS(hit.decDeg));
    if ('maj' in hit && hit.maj != null) wCell.setValue(Number(hit.maj).toFixed(2));
    if ('min' in hit && hit.min != null) hCell.setValue(Number(hit.min).toFixed(2));

    // (duplicate checks… unchanged)
    const dupEntryMsg = isDuplicateInEntrySheet_(sh, row, idRaw, nm.common || nm.catalog || idRaw);
    if (dupEntryMsg){
      status.setValue('Duplicate (Entry)').setNote(dupEntryMsg);
      _centerEntryRow_(sh, row);
      return 'Duplicate';
    }
    const dupDb = isDuplicateObject_(idRaw, nm.common || nm.catalog || idRaw);
    if (dupDb.dup){
      status.setValue('Duplicate').setNote(`Already exists in Object Database by ${dupDb.where}: ${dupDb.match}`);
      _centerEntryRow_(sh, row);
      return 'Duplicate';
    }

    status.setValue('Success');
    _centerEntryRow_(sh, row);
    return 'Success';

  } catch (e) {
    status.setValue('Error').setNote(e.message || String(e));
    _centerEntryRow_(sh, row);
    return 'Error';
  }
}


/** Writes values + duplicate checks (uses your existing helpers). */
function _SkyPix_WriteObjectRow_(sh, row, idRaw, r, okLabel){
  const nameCell = sh.getRange(row, 2);
  const raCell   = sh.getRange(row, 3);
  const decCell  = sh.getRange(row, 4);
  const wCell    = sh.getRange(row, 5);
  const hCell    = sh.getRange(row, 6);
  const status   = sh.getRange(row, 7);

  // Object Name: show common name if available, otherwise catalog name, otherwise Object ID
  const nm = _splitResolvedName_(r.main_id || idRaw);
  nameCell.setValue(nm.common || nm.catalog || idRaw);

  raCell.setValue(_degToHMS(r.raDeg));
  decCell.setValue(_degToDMS(r.decDeg));
  if (r.maj != null) wCell.setValue(Number(r.maj).toFixed(2));
  if (r.min != null) hCell.setValue(Number(r.min).toFixed(2));

  // duplicate checks you already have
  const dupEntryMsg = isDuplicateInEntrySheet_(sh, row, idRaw, nm.common || nm.catalog || idRaw);
  if (dupEntryMsg){ status.setValue('Duplicate (Entry)'); status.setNote(dupEntryMsg); return 'Duplicate'; }
  const dupDb = isDuplicateObject_(idRaw, nm.common || nm.catalog || idRaw);
  if (dupDb.dup){ status.setValue('Duplicate'); status.setNote(`Already exists in Object Database by ${dupDb.where}: ${dupDb.match}`); return 'Duplicate'; }

  // r must include: r.raDeg, r.decDeg (deg) and optionally r.pmra, r.pmdec (mas/yr)
  const now = new Date();
  const jnow = toEpochOfDate_(r.raDeg, r.decDeg, r.pmra||0, r.pmdec||0, now);

  // Write epoch-of-date to the sheet
  raCell.setValue(_degToHMS(jnow.raDeg));
  decCell.setValue(_degToDMS(jnow.decDeg));

  // Optional: keep the raw J2000 in a note for traceability
  raCell.setNote(`J2000: ${_degToHMS(r.raDeg)}`);
  decCell.setNote(`J2000: ${_degToDMS(r.decDeg)}`);

  status.setValue(okLabel);
  return okLabel;
}

/** Menu tester you can run on the active row (keep this): */
function SkyPix_Debug_TestObjectFetch_(){
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Object Entry');
  if (!sh) return ss.toast('Object Entry not found.');
  const row = sh.getActiveCell().getRow();
  if (row < 5) return ss.toast('Click a row ≥ 5 in column A with an Object ID first.');
  const aCell = sh.getRange(row, 1);
  if (!aCell.getDisplayValue()) return ss.toast('Enter an Object ID in column A first (e.g., M42).');
  const res = fetchSimbadData(aCell);
  ss.toast('Lookup result: ' + res);
}

function processObjectEntries_() {
    const ss = SpreadsheetApp.getActive();
    const entrySheet = ss.getSheetByName('Object Entry');
    if (!entrySheet) return;
    const allData = entrySheet.getRange('A5:G' + entrySheet.getLastRow()).getValues();
    if (allData.filter(row => row[6] === 'Success' && row[0] !== '').length > 0) {
      showProgressPie_();
    } else {
      ss.toast('No new valid objects to update.');
    }
}

function doObjectUpdate() {
  const ss = SpreadsheetApp.getActive();
  const entrySheet = ss.getSheetByName('Object Entry');
  const dbSheet = ss.getSheetByName('Object Database');
  if (!entrySheet || !dbSheet) return { message: "Error: Could not find required sheets." };

  const data = entrySheet.getRange('A5:G' + entrySheet.getLastRow()).getValues();
  const validObjects = data.filter(row => row[6] === 'Success' && row[0] !== '');
  if (validObjects.length === 0) return { message: "No new valid objects to update." };

  // 1) Append to DB (A..D: ID, Name, RA, Dec)
  const startRow = dbSheet.getLastRow() + 1;
  dbSheet.getRange(startRow, 1, validObjects.length, 4)
        .setValues(validObjects.map(row => [row[0], row[1], row[2], row[3]]));

  // 2) Sort DB rows (5+) by RA (column C)
  sortObjectDatabaseByRA_();

  // 3) Clear Object Entry rows
  entrySheet.getRange('A5:G' + entrySheet.getLastRow()).clearContent();

  // 4) Reset the refresh bar on Object Entry to neutral (two options)
  styleRefreshBarNeutral_(entrySheet);

  return { message: `Successfully added ${validObjects.length} object(s).` };
}

function sortObjectDatabaseByRA_(){
  const sh = SpreadsheetApp.getActive().getSheetByName('Object Database');
  if (!sh) return;

  const first = 5, last = sh.getLastRow();
  if (last < first) return;

  // Grab all visible columns (A..Z per your layout)
  const width = 26;
  const range = sh.getRange(first, 1, last - first + 1, width);
  const data  = range.getValues();

  data.sort((a, b) => {
    const raA = _raHmsToDegrees_(a[2]); // column C (0-based idx 2)
    const raB = _raHmsToDegrees_(b[2]);
    if (isNaN(raA) && isNaN(raB)) return 0;
    if (isNaN(raA)) return 1; // push blanks to bottom
    if (isNaN(raB)) return -1;
    return raA - raB;
  });

  range.setValues(data);
}



function updateCoordinates(lat, lng, elev, utc, context, targetCellA1) {
  const ss = SpreadsheetApp.getActive();
  
  if (context === 'Setup') {
    const setupSheet = ss.getSheetByName('Setup');
    if (setupSheet) {
      const range = setupSheet.getRange('C4:C7');
      range.setValues([[lat.toFixed(6)], [lng.toFixed(6)], [utc], [elev]]);
      range.setBackground(null);
            setupSheet.getRange('C4:C5').setNumberFormat('0.' + '0'.repeat(LATLON_DECIMALS));
      setupSheet.getRange('C7').setNumberFormat('0');
      range.setBackground(null);
      enforceSetupFormats_(setupSheet); // <— ensure formats stick
      refreshSetupC4Dropdown_?.();      // if you have it
      setSetupLatLonValidation_();      // keep validation sane
      enforceSetupFormats_(sh);
      return "Setup coordinates updated.";
    }
  } else if (context === 'Rig kit') {
    const rigSheet = ss.getSheetByName('Rig kit');
    if (rigSheet && targetCellA1) {
      // Parse the target cell to get the column
      const targetCell = rigSheet.getRange(targetCellA1);
      const col = targetCell.getColumn();
      
      // Clear dropdown validation and set latitude value
      rigSheet.getRange(9, col, 1, 2).merge().clearDataValidations().setValue(lat.toFixed(6)).setBackground(null);
      // Set number validation for latitude
      const latValidation = SpreadsheetApp.newDataValidation().requireNumberBetween(-90, 90).setAllowInvalid(true).build();
      rigSheet.getRange(9, col, 1, 2).setDataValidation(latValidation);
      
      // Update other location fields
      rigSheet.getRange(10, col, 1, 2).merge().setValue(lng.toFixed(6)).setBackground(null);  // Longitude  
      rigSheet.getRange(11, col, 1, 2).merge().setValue(elev).setBackground(null);            // Elevation
      rigSheet.getRange(12, col, 1, 2).merge().setValue(utc).setBackground(null);             // UTC Offset
      
      rigSheet.getRange(11, col, 1, 2).merge()
        .setValue(Math.round(Number(elev || 0)))
        .setBackground(null)
        .setNumberFormat('0');                // <— make elevation integer

      enforceRigFormats_();                   // <— re-apply formats for the pair
      return "Rig coordinates updated.";

    }
  }
  return "Error: Target sheet not found.";
}

/* ======================= COMPLETE RIG KIT MODULE (RESTRUCTURED) ======================= */

const RK_RDEF_LABELS = [
  'Rig model', 'Aperture (mm)', 'Central obstruction (mm)', 'Effective aperture area (mm²)', 
  'Effective focal length (mm)', 'Latitude (degrees [N+ / S-])', 'Longitude (degrees [E+ / W-])', 
  'Elevation above sea level (m)', 'Timezone UTC', 'DST start (MM-DD-YY)', 'DST end (MM-DD-YY)'
];

const RK_DFS_LABELS = [
  'Darkness convention',
  'Times reported based on...',
  'Object visibility reported as...',
  'Display objects observable for the next... (months)',
  'Display objects with a minimum observable time of... (minutes)',
  'Display objects between declinations... (degrees)'
];

const RK_IMC_LABELS = [
  'Maximum integration time (minutes)', 'Maximum subframe exposure (seconds)', 'Minimum object elevation (degrees)',
  'Lunar avoidance angle (degrees)', 'Expected ambient temp (°C)', 'Sky Brightness (either Bortle Class or mag/arcsec^2)', 'Air quality index'
];

const RK_RDEF_START_ROW = 4;
const RK_COLOR_ROW = 16;
const RK_DFS_START_ROW = 18;
const RK_IMC_START_ROW = 27;
const RK_CRASH_CONE_START_ROW = 35;
const RK_HORIZON_HDR_ROW = 40;

function buildRigKit_(ss) {
  const sh = ss.getSheetByName('Rig kit') || ss.insertSheet('Rig kit', 2);
  sh.clear(); sh.setName('Rig kit');
  sh.clearConditionalFormatRules();

  sh.setColumnWidth(1, 200).setColumnWidths(2, sh.getMaxColumns() - 1, 45);
  sh.setRowHeights(1, sh.getMaxRows(), ROW_H_ALL);
  sh.setRowHeight(RK_COLOR_ROW, 36);

  // Rig Definition Labels (rows 4-14)
  RK_RDEF_LABELS.forEach((t, i) => {
    const cell = leftLabel_(sh.getRange(RK_RDEF_START_ROW + i, 1)).setValue(t).setWrap(true);
    if (i === 0) cell.setWrap(true);
  });

  // Acknowledge Defaults row (Row 15)
  leftLabel_(sh.getRange(15, 1)).setValue('Acknowledge Defaults').setFontSize(10).setFontWeight('normal').setFontColor(DARK_GREY_FONT);

  // Rig Highlight Color row (Row 16)
  leftLabel_(sh.getRange(RK_COLOR_ROW, 1)).setValue('Rig Highlight Color').setFontSize(10).setFontWeight('normal').setFontColor(DARK_GREY_FONT);

  // Safe merge function
  const RK_safeFullWidthMerge = (row) => {
    try {
      const width = Math.max(3, RK_getActiveWidth_(sh) || 3);
      const range = sh.getRange(row, 1, 1, width);
      range.breakApart();
      range.merge();
    } catch (e) {
      console.log(`Merge warning for row ${row}: ${e.message}`);
    }
  };

  // Merge headers and section rows safely (including blank rows 17, 25, 39)
  [1, 2, 17, 18, 25, 26, 34, RK_CRASH_CONE_START_ROW, 39, RK_HORIZON_HDR_ROW].forEach(RK_safeFullWidthMerge);

  // Set section content
  sh.getRange(1, 1).setValue('Rig Kit');
  sh.getRange(17, 1).setValue(''); // blank
  sh.getRange(18, 1).setValue('Display Content');
  sh.getRange(25, 1).setValue(''); // blank
  sh.getRange(26, 1).setValue('Imaging Constraints');
  sh.getRange(34, 1).setValue('');
  sh.getRange(RK_CRASH_CONE_START_ROW, 1).setValue('Zenith Obstruction');
  sh.getRange(39, 1).setValue(''); // blank
  sh.getRange(RK_HORIZON_HDR_ROW, 1).setValue('Landscape Horizon');

  // DISPLAY CONTENT LABELS (rows 19-24)
  RK_DFS_LABELS.forEach((label, i) => {
    const row = RK_DFS_START_ROW + 1 + i;
    const cell = leftLabel_(sh.getRange(row, 1)).setValue(label).setWrap(true);
    
    switch (i) {
      case 0: cell.setNote('Choose between Astronomical and Nautical twilight for darkness calculations'); break;
      case 1: cell.setNote('Base timing calculations on object transit or rising times'); break;
      case 2: cell.setNote('Report visibility windows as general visibility or optimal imaging conditions'); break;
      case 3: cell.setNote('Set forecast period for object visibility planning'); break;
      case 4: cell.setNote('Minimum continuous observation time required for an object to be included'); break;
      case 5: cell.setNote('Declination range limits for object visibility at your location'); break;
    }
  });

  // IMAGING CONSTRAINTS LABELS (rows 27-33)
  RK_IMC_LABELS.forEach((label, i) => {
    const cell = leftLabel_(sh.getRange(RK_IMC_START_ROW + i, 1)).setValue(label).setWrap(true);
    
    switch (i) {
      case 0: cell.setNote('Total time allocated for imaging this target across all sessions'); break;
      case 1: cell.setNote('Maximum exposure time per individual subframe to avoid trailing or saturation'); break;
      case 2: cell.setNote('Minimum altitude above horizon required for acceptable image quality'); break;
      case 3: cell.setNote('Angular distance from moon required to avoid interference'); break;
      case 4: cell.setNote('Expected ambient temperature for sensor cooling calculations'); break;
      case 5: cell.setNote('Local sky darkness rating affecting signal-to-noise ratio'); break;
      case 6: cell.setNote('Atmospheric transparency measurement affecting image quality'); break;
    }
  });

  // Zenith obstruction labels with note (A35)
  rightLabel_(sh.getRange(RK_CRASH_CONE_START_ROW + 1, 1)).setValue('Leg 1');
  rightLabel_(sh.getRange(RK_CRASH_CONE_START_ROW + 2, 1)).setValue('Leg 2');
  rightLabel_(sh.getRange(RK_CRASH_CONE_START_ROW + 3, 1)).setValue('Leg 3');
  sh.getRange(RK_CRASH_CONE_START_ROW, 1).setNote('Define zenith obstruction cone using three azimuth/altitude coordinate pairs');
  sh.getRange(RK_HORIZON_HDR_ROW, 1).setNote('Define landscape horizon profile using azimuth/altitude coordinate pairs for terrain masking');

  const addRigCell = sh.getRange('A3');
  addRigCell.setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(['Add Rig', 'Cancel'], true).setAllowInvalid(true).build());
  sh.getRange('B3').setValue('Rig 1');
  sh.getRange('B4:C34').setHorizontalAlignment('center').setVerticalAlignment('middle');

  RK_applyRigPairMerges_(sh, 2);
  
  sh.setRowHeights(RK_CRASH_CONE_START_ROW + 1, 3, 36);
  sh.setRowHeight(RK_HORIZON_HDR_ROW, 36);
  sh.setRowHeights(RK_HORIZON_HDR_ROW + 1, 101, 36);

  RK_applyRigPairValidations_(sh, 2);
  RK_setupColorPickers_(sh);
  RK_setDefaultValues_(sh);
  RK_setupRigHelpers_(sh);
  RK_setupAcknowledgeDefaults_(sh);

  sh.setFrozenRows(3);
  recolorRigKitBands_(sh);
  enforceRigFormats_();
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_RIG);
}

function RK_getActiveWidth_(sh) {
  let width = 1;
  let c = 2;
  while (c <= sh.getMaxColumns()) {
    const headerValue = sh.getRange(3, c).getDisplayValue().trim();
    if (headerValue && headerValue.match(/^Rig\s+\d+$/)) {
      width = c + 1;
      c += 2;
    } else {
      break;
    }
  }
  return width;
}

function recolorRigKitBands_(sh) {
  if (!sh) return;
  const hpc = getHPC_Global_();
  const width = RK_getActiveWidth_(sh);
  const borderColor = hpcShade(hpc, 40);

  const title = sh.getRange(1, 1, 1, width).merge();
  title.setValue('Rig Kit').setBackground(hpcShade(hpc, 80)).setFontSize(16).setFontWeight('bold').setFontColor('#FFFFFF').setHorizontalAlignment('center').setVerticalAlignment('middle').setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);

  const addCell = sh.getRange('A3');
  const addBg = hpcShade(hpc, 20);
  addCell.setBackground(addBg).setFontSize(12).setFontWeight('bold').setFontColor('#FFFFFF').setHorizontalAlignment('center').setVerticalAlignment('middle');
  stylePaddedCell_(addCell, 'Add Rig...', addBg, '#FFFFFF', true);

  if (width > 1) {
    const rigHeaders = sh.getRange(3, 2, 1, width - 1);
    rigHeaders.setBackground(hpcShade(hpc, 40)).setFontSize(12).setFontWeight('bold').setFontColor('#FFFFFF').setHorizontalAlignment('center').setVerticalAlignment('middle');
  }

  const subheaderRows = [2, 18, 26, RK_CRASH_CONE_START_ROW, RK_HORIZON_HDR_ROW];
  subheaderRows.forEach(row => {
    const subheader = sh.getRange(row, 1, 1, width);
    subheader.setBackground(hpcShade(hpc, 30)).setFontSize(12).setFontWeight('bold').setFontColor(DARK_GREY_FONT).setHorizontalAlignment('center').setVerticalAlignment('middle').setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);
  });

  // Blank rows: 17, 25, 34, 39
  [17, 25, 34, 39].forEach(row => {
    const blankRange = sh.getRange(row, 1, 1, width).merge();
    blankRange.setValue('').setBackground(null);
  });

  for (let row = 36; row <= 38; row++) {
    sh.getRange(row, 1).setFontSize(10).setFontWeight('normal').setFontColor(DARK_GREY_FONT).setHorizontalAlignment('right').setVerticalAlignment('middle');
  }

  sh.getRange(1, 1, sh.getFrozenRows(), width).setBorder(true, true, true, true, null, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);
  sh.getRange('A4:A15').setHorizontalAlignment('left').setVerticalAlignment('middle').setWrap(true);
  sh.getRange('A16:A16').setHorizontalAlignment('left').setVerticalAlignment('middle').setWrap(true);
  sh.getRange('A19:A24').setHorizontalAlignment('left').setVerticalAlignment('middle').setWrap(true);
  sh.getRange('A27:A33').setHorizontalAlignment('left').setVerticalAlignment('middle').setWrap(true);
  RK_paintAllDataCellsOrange_(sh);
}

function RK_paintAllDataCellsOrange_(sh) {
  const width = RK_getActiveWidth_(sh);
  if (width <= 1) return;
  // Removed row 7 (calculated), removed row 15 (acknowledge defaults checkbox)
  const dataRowRanges = [[4, 6], [8, 14], [16, 16], [19, 24], [27, 33], [36, 38], [41, 50]];
  dataRowRanges.forEach(([startRow, endRow]) => {
    const range = sh.getRange(startRow, 2, endRow - startRow + 1, width - 1);
    range.setBackground(WARN_ORANGE);
  });
}

function RK_applyRigPairMerges_(sh, cL) {
  const rowsToMerge = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19, 20, 21];
  rowsToMerge.forEach(r => {
    try { sh.getRange(r, cL, 1, 2).breakApart(); sh.getRange(r, cL, 1, 2).merge(); } catch (e) {}
  });
  for (let r = 27; r <= 33; r++) {
    try { sh.getRange(r, cL, 1, 2).breakApart(); sh.getRange(r, cL, 1, 2).merge(); } catch (e) {}
  }
}

function RK_applyRigPairValidations_(sh, cL) {
  try {
    const setupSheet = SpreadsheetApp.getActive().getSheetByName('Setup');
    const defaults = setupSheet ? setupSheet.getRange('C4:C9').getValues().flat() : [null, null, null, null, null, null];
    const dvNum = (a, b) => SpreadsheetApp.newDataValidation().requireNumberBetween(a, b).setAllowInvalid(true).build();
    const dvDate = SpreadsheetApp.newDataValidation().requireDate().setAllowInvalid(true).build();

    sh.getRange(4, cL, 1, 2).setWrap(true);
    
    // Row 5: Aperture (10-2000)
    sh.getRange(5, cL, 1, 2).setDataValidation(dvNum(10, 2000));
    
    // Row 6: Central obstruction (0-200)
    sh.getRange(6, cL, 1, 2).setDataValidation(dvNum(0, 200));

    // Row 7: Effective aperture area - FORMULA ONLY, not editable
    const areaCell = sh.getRange(7, cL, 1, 2);
    if (!areaCell.getValue()) {
      const apertureCell = sh.getRange(5, cL);
      const obstructionCell = sh.getRange(6, cL);
      const areaFormula = `=PI()*(${apertureCell.getA1Notation()}/2)^2-PI()*(${obstructionCell.getA1Notation()}/2)^2`;
      areaCell.setFormula(areaFormula).setNumberFormat('0.00');
    }
    areaCell.setBackground('#f3f3f3').setFontColor('#666666');
    const protection = areaCell.protect().setDescription('Calculated field');
    protection.setWarningOnly(true);
    
    // Row 8: Effective focal length (50-10000)
    sh.getRange(8, cL, 1, 2).setDataValidation(dvNum(50, 10000));

    // Row 9-14: Location data with defaults
    const finderDv = SpreadsheetApp.newDataValidation().requireValueInList(['Retrieve 4D Location', 'Cancel']).setAllowInvalid(true).build();
    const latRng = sh.getRange(9, cL, 1, 2);
    const lonRng = sh.getRange(10, cL, 1, 2);
    const elvRng = sh.getRange(11, cL, 1, 2);
    const utcRng = sh.getRange(12, cL, 1, 2);
    const dstStartRng = sh.getRange(13, cL, 1, 2);
    const dstEndRng = sh.getRange(14, cL, 1, 2);

    if (!latRng.getValue()) latRng.setValue(defaults[0]).setBackground(WARN_ORANGE);
    if (!lonRng.getValue()) lonRng.setValue(defaults[1]).setBackground(WARN_ORANGE);
    if (!elvRng.getValue()) elvRng.setValue(defaults[3]).setBackground(WARN_ORANGE);
    if (!utcRng.getValue()) utcRng.setValue(defaults[2]).setBackground(WARN_ORANGE);
    if (!dstStartRng.getValue()) dstStartRng.setValue(defaults[4]).setBackground(WARN_ORANGE);
    if (!dstEndRng.getValue()) dstEndRng.setValue(defaults[5]).setBackground(WARN_ORANGE);

    latRng.setDataValidation(finderDv).setWrap(true);
    lonRng.setDataValidation(dvNum(-180, 180)).setNumberFormat('0.0000');
    elvRng.setDataValidation(dvNum(-100, 5000)).setNumberFormat('0');
    utcRng.setDataValidation(dvNum(-12, 12));
    dstStartRng.setDataValidation(dvDate).setNumberFormat('MM-dd-yy');
    dstEndRng.setDataValidation(dvDate).setNumberFormat('MM-dd-yy');

    // Display format dropdowns
    sh.getRange(19, cL, 1, 2).setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(['Astro', 'Nautical'], true).setAllowInvalid(true).build());
    sh.getRange(20, cL, 1, 2).setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(['Transit', 'Rising'], true).setAllowInvalid(true).build());
    sh.getRange(21, cL, 1, 2).setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(['Visible', 'Optimum'], true).setAllowInvalid(true).build());
    
    // Row 22: Observable months (1-12)
    sh.getRange(22, cL, 1, 2).setDataValidation(dvNum(1, 12));
    
    // Row 23: Minimum observable time (10-480)
    sh.getRange(23, cL, 1, 2).setDataValidation(dvNum(10, 480));
    
    // Row 24: Declination limits (-90 to +90) - NOT merged, separate cells
    sh.getRange(24, cL).setDataValidation(dvNum(-90, 90));
    sh.getRange(24, cL + 1).setDataValidation(dvNum(-90, 90));
    
    // Row 27: Max integration time (blank or 1-9999)
    sh.getRange(27, cL, 1, 2).setDataValidation(dvNum(0, 9999));
    
    // Row 28: Max subframe exposure (blank or 1-999)
    sh.getRange(28, cL, 1, 2).setDataValidation(dvNum(0, 999));
    
    // Row 29: Min object elevation (blank or 1-80)
    sh.getRange(29, cL, 1, 2).setDataValidation(dvNum(0, 80));
    
    // Row 30: Lunar avoidance (blank or 1-90)
    sh.getRange(30, cL, 1, 2).setDataValidation(dvNum(0, 90));
    
    // Row 31: Ambient temp (-50 to +50)
    sh.getRange(31, cL, 1, 2).setDataValidation(dvNum(-50, 50));
    
    // Row 32: Sky Brightness (1.0-9.0 for Bortle, 14.0-25.0 for mag/arcsec²)
    // Using custom validation that allows decimals in both ranges
    const skyBrightnessFormula = '=OR(AND(B32>=1,B32<=9),AND(B32>=14,B32<=25))';
    sh.getRange(32, cL, 1, 2).setDataValidation(
      SpreadsheetApp.newDataValidation()
        .requireNumberBetween(1, 25)
        .setAllowInvalid(false)
        .setHelpText('Enter Bortle Class (1.0-9.0) or magnitude per square arcsecond (14.0-25.0)')
        .build()
    );
    
    // Row 33: Air quality (blank or 0-200) - allow web retrieval to override
    sh.getRange(33, cL, 1, 2).setDataValidation(dvNum(0, 200));
    
    // Rows 36-38: Zenith obstruction (Az: 0-360, Alt: 0-90)
    for (let r = 36; r <= 38; r++) {
      sh.getRange(r, cL).setDataValidation(dvNum(0, 360));
      sh.getRange(r, cL + 1).setDataValidation(dvNum(0, 90));
    }
    
    // Set data validation warning colors (paint yellow on invalid entry)
    const validationRanges = [
      [5, cL, 1, 2], [6, cL, 1, 2], [8, cL, 1, 2],
      [9, cL, 1, 2], [10, cL, 1, 2], [11, cL, 1, 2], [12, cL, 1, 2],
      [22, cL, 1, 2], [23, cL, 1, 2], [24, cL], [24, cL + 1],
      [27, cL, 1, 2], [28, cL, 1, 2], [29, cL, 1, 2], [30, cL, 1, 2],
      [31, cL, 1, 2], [32, cL, 1, 2], [33, cL, 1, 2]
    ];
    validationRanges.forEach(coords => {
      const range = coords.length === 4 ? sh.getRange(coords[0], coords[1], coords[2], coords[3]) : sh.getRange(coords[0], coords[1]);
      range.setDataValidation(range.getDataValidation().copy().setAllowInvalid(true).build());
    });
    
  } catch (e) {
    console.log('Validation error:', e.message);
  }
}

function RK_setupColorPickers_(sh) {
  try {
    const pairs = getPairsFromHeaders_(sh);
    const colorNames = COLOR_PICKER ? COLOR_PICKER.map(r => r[0]) : ['Blue', 'Red', 'Green', 'Purple'];
    const dv = SpreadsheetApp.newDataValidation().requireValueInList(colorNames, true).setAllowInvalid(true).build();
    
    pairs.forEach(([cL, cR]) => {
      const cell = sh.getRange(16, cL, 1, 2);
      try { 
        cell.breakApart(); 
        cell.merge(); 
        cell.setDataValidation(dv); 
        cell.setHorizontalAlignment('center').setVerticalAlignment('middle');
        // Set default to Blue color (not just HPC), clear text
        const blueHex = nameToHex_('Blue') || getHPC_Global_();
        cell.setBackground(blueHex).setValue('');
      } catch (e) {}
    });
  } catch (e) {}
}

function RK_setDefaultValues_(sh) {
  try {
    const pairs = getPairsFromHeaders_(sh);
    pairs.forEach(([cL, cR]) => {
      // Row 22: Default 3 months
      if (!sh.getRange(22, cL, 1, 2).getValue()) {
        sh.getRange(22, cL, 1, 2).setValue(3).setBackground(WARN_ORANGE).setHorizontalAlignment('center').setVerticalAlignment('middle');
      }
      // Row 23: Default 60 minutes
      if (!sh.getRange(23, cL, 1, 2).getValue()) {
        sh.getRange(23, cL, 1, 2).setValue(60).setBackground(WARN_ORANGE).setHorizontalAlignment('center').setVerticalAlignment('middle');
      }
    });
  } catch (e) {}
}

function RK_setupAcknowledgeDefaults_(sh) {
  try {
    const pairs = getPairsFromHeaders_(sh);
    pairs.forEach(([cL, cR]) => {
      const cell = sh.getRange(15, cL, 1, 2);
      try { cell.breakApart(); cell.merge(); cell.insertCheckboxes(); cell.setHorizontalAlignment('center').setVerticalAlignment('middle'); } catch (e) {}
    });
  } catch (e) {}
}

function RK_setupRigHelpers_(sh) {
  try {
    const pairs = getPairsFromHeaders_(sh);
    try {
      const width = RK_getActiveWidth_(sh) || 3;
      sh.getRange(24, 2, 1, width - 1).breakApart();
      for (let c = 2; c <= width; c += 2) {
        if (c + 1 <= sh.getMaxColumns()) {
          sh.getRange(24, c).setValue("> Dec").setHorizontalAlignment('center');
          sh.getRange(24, c + 1).setValue("< Dec").setHorizontalAlignment('center');
        }
      }
    } catch (e) {}
    const RK_CRASH_CONE_START_ROW = 35;
    pairs.forEach(([cL, cR]) => {
      for (let i = 0; i < 3; i++) {
        const row = RK_CRASH_CONE_START_ROW + 1 + i;
        sh.getRange(row, cL).setValue('Az');
        sh.getRange(row, cR).setValue('Alt');
        sh.getRange(row, cL, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle');
      }
    });
    const RK_HORIZON_HDR_ROW = 40;
    pairs.forEach(([cL, cR]) => {
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cL).setValue('Az');
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cR).setValue('Alt');
      sh.getRange(RK_HORIZON_HDR_ROW + 2, cL).setValue('');
      sh.getRange(RK_HORIZON_HDR_ROW + 2, cR).setValue('');
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cL, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle');
    });
  } catch (e) {}
}

function enforceRigFormats_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  try {
    getPairsFromHeaders_(sh).forEach(([cL]) => {
      sh.getRange(9, cL, 1, 2).setNumberFormat('0.0000');
      sh.getRange(10, cL, 1, 2).setNumberFormat('0.0000');
      sh.getRange(11, cL, 1, 2).setNumberFormat('0');
      sh.getRange(13, cL, 1, 2).setNumberFormat('MM-dd-yy');
      sh.getRange(14, cL, 1, 2).setNumberFormat('MM-dd-yy');
    });
  } catch (e) {}
}

function SkyPix_AddRig_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  try {
    const width = RK_getActiveWidth_(sh);
    const newCol = width + 1;
    
    // Insert 2 new columns to the RIGHT of existing rigs
    if (newCol + 1 > sh.getMaxColumns()) { 
      sh.insertColumnsAfter(sh.getMaxColumns(), 2); 
    } else { 
      sh.insertColumnsAfter(newCol - 1, 2); 
    }
    sh.setColumnWidths(newCol, 2, 45);
    
    const existingRigs = Math.floor((width - 1) / 2);
    const rigNumber = existingRigs + 1;
    
    // Set header with HPC styling
    sh.getRange(3, newCol, 1, 2).merge().setValue(`Rig ${rigNumber}`);
    const hpc = getHPC_Global_();
    sh.getRange(3, newCol, 1, 2).setBackground(hpcShade(hpc, 40)).setFontSize(12).setFontWeight('bold').setFontColor('#FFFFFF').setHorizontalAlignment('center').setVerticalAlignment('middle');
    
    // Apply merges for the new rig ONLY
    RK_applyRigPairMerges_(sh, newCol);
    
    // Apply ALL validations and defaults for new rig
    RK_applyRigPairValidations_(sh, newCol);
    
    // Paint ONLY the new rig's cells orange (excluding row 7 which is grey formula)
    const dataRowRanges = [[4, 6], [8, 14], [16, 16], [19, 24], [27, 33], [36, 38], [41, 50]];
    dataRowRanges.forEach(([startRow, endRow]) => {
      sh.getRange(startRow, newCol, endRow - startRow + 1, 2).setBackground(WARN_ORANGE).setHorizontalAlignment('center').setVerticalAlignment('middle');
    });
    
    // Set up color picker dropdown with Blue as default color
  const colorNames = ['Blue', 'Deep Blue', 'Steel Blue', 'Cyan', 'Light Blue', 'Cornflower', 'Green', 'Teal', 'Purple', 'Magenta', 'Red', 'Red Berry', 'Maroon', 'Brown', 'Slate', 'Navy', 'Dk Green'];
  const dv = SpreadsheetApp.newDataValidation().requireValueInList(colorNames, true).setAllowInvalid(true).build();
  
  sh.getRange(16, newCol, 1, 2).setDataValidation(dv).setBackground('#1E90FF').setValue('');
    
    // Set up acknowledge defaults checkbox for new rig
    sh.getRange(15, newCol, 1, 2).insertCheckboxes().setHorizontalAlignment('center').setVerticalAlignment('middle');
    
    // Set default values for rows 22 and 23
    sh.getRange(22, newCol, 1, 2).setValue(3).setHorizontalAlignment('center').setVerticalAlignment('middle');
    sh.getRange(23, newCol, 1, 2).setValue(60).setHorizontalAlignment('center').setVerticalAlignment('middle');
    
    // Set up helper text for new rig ONLY (don't touch existing rigs)
    sh.getRange(24, newCol).setValue("> Dec").setHorizontalAlignment('center').setVerticalAlignment('middle');
    sh.getRange(24, newCol + 1).setValue("< Dec").setHorizontalAlignment('center').setVerticalAlignment('middle');
    
    // Zenith helpers for new rig ONLY
    for (let i = 0; i < 3; i++) {
      const row = 36 + i;
      sh.getRange(row, newCol).setValue('Az').setHorizontalAlignment('center').setVerticalAlignment('middle');
      sh.getRange(row, newCol + 1).setValue('Alt').setHorizontalAlignment('center').setVerticalAlignment('middle');
    }
    
    // Landscape Horizon helpers for new rig ONLY (rows 41-50 centered)
    sh.getRange(41, newCol).setValue('Az').setHorizontalAlignment('center').setVerticalAlignment('middle');
    sh.getRange(41, newCol + 1).setValue('Alt').setHorizontalAlignment('center').setVerticalAlignment('middle');
    for (let r = 42; r <= 50; r++) {
      sh.getRange(r, newCol, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle');
    }
    
    // Expand dynamic blank rows to include new rig
    RK_expandBlankRows_(sh);
    
    // Expand subheaders to include new rig
    [2, 17, 18, 25, 26, 34, 35, 39, 40].forEach(row => {
      try {
        const range = sh.getRange(row, 1, 1, newCol + 1);
        range.breakApart();
        range.merge();
      } catch (e) {}
    });
    
    SpreadsheetApp.getActive().toast(`Rig ${rigNumber} added successfully.`);
  } catch (e) { 
    SpreadsheetApp.getActive().toast('Error adding rig: ' + e.message); 
  }
  // Apply validation fixes to the new rig
  rigkit_mergeRows2223_();
  rigkit_fixRow32Validation_();
  rigkit_fixColorPicker_();
  rigkit_paintBlanksYellow_();
  
  // Apply validation fixes to the newly added rig
  const newPairs = [[newCol, newCol + 1]];
  
  // Merge rows 22-23 for the new rig
  try {
    sh.getRange(22, newCol, 1, 2).merge();
    sh.getRange(23, newCol, 1, 2).merge();
  } catch (e) {}
  
  // Set up color picker with Blue default
  const colorNames = COLOR_PICKER ? COLOR_PICKER.map(r => r[0]) : ['Blue', 'Red', 'Green', 'Purple'];
  const dv = SpreadsheetApp.newDataValidation().requireValueInList(colorNames, true).setAllowInvalid(true).build();
  const blueHex = nameToHex_('Blue') || getHPC_Global_();
  sh.getRange(16, newCol, 1, 2).setDataValidation(dv).setBackground(blueHex).setValue('');
  
  SpreadsheetApp.getActive().toast('Rig added.');
}

function RK_expandBlankRows_(sh) {
  const width = RK_getActiveWidth_(sh);
  [17, 25, 34, 39].forEach(row => {
    try { 
      const range = sh.getRange(row, 1, 1, width); 
      range.breakApart(); 
      range.merge();
      range.setValue('').setBackground(null);
    } catch (e) {}
  });
}

function RK_updateAllRigHelpers_(sh) {
  try {
    const pairs = getPairsFromHeaders_(sh);
    pairs.forEach(([cL, cR]) => {
      sh.getRange(24, cL).setValue("> Dec").setHorizontalAlignment('center');
      sh.getRange(24, cR).setValue("< Dec").setHorizontalAlignment('center');
    });
    const colorNames = COLOR_PICKER ? COLOR_PICKER.map(r => r[0]) : ['Blue', 'Red', 'Green', 'Purple'];
    const dv = SpreadsheetApp.newDataValidation().requireValueInList(colorNames, true).setAllowInvalid(true).build();
    const hpc = getHPC_Global_();
    pairs.forEach(([cL, cR]) => { 
      const cell = sh.getRange(16, cL, 1, 2); 
      cell.setDataValidation(dv); 
      cell.setBackground(hpc).setValue('');
    });
    pairs.forEach(([cL, cR]) => { 
      const cell = sh.getRange(15, cL, 1, 2); 
      try { 
        cell.breakApart(); 
        cell.merge(); 
        cell.insertCheckboxes(); 
        cell.setHorizontalAlignment('center').setVerticalAlignment('middle'); 
      } catch (e) {} 
    });
    const RK_CRASH_CONE_START_ROW = 35;
    pairs.forEach(([cL, cR]) => { 
      for (let i = 0; i < 3; i++) { 
        const row = RK_CRASH_CONE_START_ROW + 1 + i; 
        sh.getRange(row, cL).setValue('Az'); 
        sh.getRange(row, cR).setValue('Alt'); 
        sh.getRange(row, cL, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle'); 
      } 
    });
    const RK_HORIZON_HDR_ROW = 40;
    pairs.forEach(([cL, cR]) => { 
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cL).setValue('Az'); 
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cR).setValue('Alt'); 
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cL, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle'); 
    });
    const finderDv = SpreadsheetApp.newDataValidation().requireValueInList(['Retrieve 4D Location', 'Cancel']).setAllowInvalid(true).build();
    pairs.forEach(([cL, cR]) => { 
      sh.getRange(9, cL, 1, 2).setDataValidation(finderDv); 
    });
    RK_setDefaultValues_(sh);
  } catch (e) {}
}

function RK_handleAcknowledgeDefaults_(e) {
  const sh = e.range.getSheet();
  if (sh.getName() !== 'Rig kit') return;
  const row = e.range.getRow();
  const col = e.range.getColumn();
  if (row !== 15 || col < 2) return;
  const isChecked = e.range.getValue();
  if (isChecked !== true) return;
  
  try {
    // Find which rig pair (column pair) this checkbox belongs to
    const pairs = getPairsFromHeaders_(sh);
    let targetPair = null;
    
    for (const [cL, cR] of pairs) {
      if (col >= cL && col <= cR) {
        targetPair = [cL, cR];
        break;
      }
    }
    
    if (!targetPair) return;
    
    const [cL, cR] = targetPair;
    
    // Data rows that should be cleared of orange if filled
    const dataRowRanges = [[4, 6], [8, 14], [16, 16], [27, 33], [36, 38]];
    
    // Critical rows that must have values - paint yellow if blank
    const criticalRanges = [
      [5, 6], [8, 12], [19, 24], [41, 44]
    ];
    
    // Clear orange from filled cells
    dataRowRanges.forEach(([startRow, endRow]) => {
      for (let r = startRow; r <= endRow; r++) {
        const cell = sh.getRange(r, cL, 1, 2);
        const bg = cell.getBackground();
        const val = cell.getValue();
        
        if (bg && bg.toLowerCase() === WARN_ORANGE.toLowerCase()) {
          cell.setBackground(null);
        }
      }
    });
    
    // Paint critical blank cells yellow
    criticalRanges.forEach(([startRow, endRow]) => {
      for (let r = startRow; r <= endRow; r++) {
        // Check merged cell value
        const cell = sh.getRange(r, cL, 1, 2);
        const val = String(cell.getValue() || '').trim();
        
        // For row 41-44, check individual cells too for "Az"
        if (r >= 41 && r <= 44) {
          const leftVal = String(sh.getRange(r, cL).getValue() || '').trim();
          const rightVal = String(sh.getRange(r, cL + 1).getValue() || '').trim();
          if (!leftVal || leftVal === 'Az') {
            sh.getRange(r, cL).setBackground(WARN_YELLOW);
          }
          if (!rightVal || rightVal === 'Alt') {
            sh.getRange(r, cL + 1).setBackground(WARN_YELLOW);
          }
        } else {
          // For merged cells, check if empty
          if (!val) {
            cell.setBackground(WARN_YELLOW);
          }
        }
      }
    });
    
  } catch (error) {
    console.log('Acknowledge Defaults processing error:', error.message);
  }
}

function RK_handleCellEdit_(e) {
  const sh = e.range.getSheet();
  if (sh.getName() !== 'Rig kit') return;
  const row = e.range.getRow();
  const col = e.range.getColumn();
  
  // Handle color picker (row 16) - paint cell and CLEAR text immediately
  if (row === 16 && col >= 2) {
    const colorName = String(e.value || '').trim();
    if (colorName && colorName !== '') {
      const hex = nameToHex_(colorName);
      if (hex) {
        e.range.setBackground(hex);
        e.range.setValue('');
        e.range.setFontColor(hexIsDark_(hex) ? '#FFFFFF' : '#000000');
        return;
      }
    }
  }
  
  // Handle Acknowledge Defaults checkbox (row 15)
  if (row === 15 && col >= 2 && e.value === true) {
    // Find which rig pair this checkbox belongs to
    const pairs = getPairsFromHeaders_(sh);
    let targetPair = null;
    
    for (const [cL, cR] of pairs) {
      if (col >= cL && col <= cR) {
        targetPair = [cL, cR];
        break;
      }
    }
    
    if (targetPair) {
      const [cL, cR] = targetPair;
      
      // Clear orange/yellow from ALL data rows in this rig's column pair
      const dataRowRanges = [[4, 6], [8, 14], [16, 16], [19, 24], [27, 33], [36, 38], [41, 50]];
      
      dataRowRanges.forEach(([startRow, endRow]) => {
        for (let r = startRow; r <= endRow; r++) {
          const cell = sh.getRange(r, cL, 1, 2);
          const bg = cell.getBackground();
          if (bg && (bg.toLowerCase() === WARN_ORANGE.toLowerCase() || bg.toLowerCase() === WARN_YELLOW.toLowerCase())) {
            cell.setBackground(null);
          }
        }
      });
    }
    return;
  }
  
  // Smart unpaint: clear orange/yellow on user edit in data ranges
  const dataRowRanges = [[4, 6], [8, 14], [16, 16], [19, 24], [27, 33], [36, 38], [41, 50]];
  const isInDataRange = dataRowRanges.some(([start, end]) => row >= start && row <= end);
  if (isInDataRange && col >= 2) {
    const bg = e.range.getBackground();
    if (bg && (bg.toLowerCase() === WARN_ORANGE.toLowerCase() || bg.toLowerCase() === WARN_YELLOW.toLowerCase())) {
      e.range.setBackground(null);
    }
  }
  
  // Preserve 4D location finder dropdown after use
  if (row === 9 && col >= 2) {
    const finderDv = SpreadsheetApp.newDataValidation()
      .requireValueInList(['Retrieve 4D Location', 'Cancel'])
      .setAllowInvalid(true)
      .build();
    e.range.setDataValidation(finderDv);
  }
}

function getLandHdrRow_(sh) {
  let row = findRowWithText_(sh, 'Landscape Horizon');
  if (row) return row;
  const afterZenith = findRowWithText_(sh, 'Zenith Obstruction');
  const insertAt = (afterZenith ? afterZenith + 2 : Math.max(1, sh.getLastRow()) + 2);
  sh.insertRows(insertAt, 3);
  sh.getRange(insertAt, 1, 1, 3).merge().setValue('Landscape Horizon').setHorizontalAlignment('left').setVerticalAlignment('middle');
  sh.getRange(insertAt + 1, 2).setValue('Az');
  sh.getRange(insertAt + 1, 3).setValue('Alt');
  return insertAt;
}

function rigkit_mergeSectionHeader_(sh, headerRow) {
  if (!sh || !headerRow) return;
  const width = Math.max(2, (typeof getActiveWidth_ === 'function' ? getActiveWidth_(sh) : sh.getMaxColumns()));
  try { sh.getRange(headerRow, 1, 1, width).merge(); } catch (e) {}
}

function rigkit_forceColorPicker_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Rig kit');
  if (!sh) { ss.toast('Rig kit sheet not found.'); return; }
  const colorRow = 16;
  const names = COLOR_PICKER.map(r => r[0]);
  const dv = SpreadsheetApp.newDataValidation().requireValueInList(names, true).setAllowInvalid(true).build();
  const pairs = getPairsFromHeaders_(sh);
  pairs.forEach(([cL]) => {
    try { sh.getRange(colorRow, cL, 1, 2).breakApart(); } catch(e){}
    sh.getRange(colorRow, cL, 1, 2).merge().setDataValidation(dv);
  });
  ss.toast('Rig color picker restored.');
}

function _rigkit_getBlocks_(sh) {
  const width = getActiveWidth_(sh);
  const blocks = [];
  let c = 2;
  while (c <= width) {
    const cell = sh.getRange(3, c);
    const text = cell.getDisplayValue();
    if (text && text.match(/^Rig\s+\d+$/)) {
      const m = cell.getMergedRanges();
      const w = (m && m.length) ? m[0].getWidth() : 2;
      blocks.push({ startCol: c, width: w });
      c += w;
    } else {
      break;
    }
  }
  return blocks;
}

function rigkit_resetRefreshBar_(sh) {
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_RIG);
}

function refreshKits_() {
  const ss = SpreadsheetApp.getActive();
  const rigSheet = ss.getSheetByName('Rig kit');
  if (!rigSheet) return;
  const rigs = _rigkit_getRigSpecs_(rigSheet);
  const cameraSheet = ss.getSheetByName('Camera Kit');
  if (cameraSheet) {
    rebuildRigEligibility_Camera_Fixed_(cameraSheet, rigs);
    recolorCameraKitBands_(cameraSheet);
  }
  const filterSheet = ss.getSheetByName('Filter Kit');
  if (filterSheet) {
    rebuildRigEligibility_Filter_Fixed_(filterSheet, rigs);
    recolorFilterKitBands_(filterSheet);
  }
  SpreadsheetApp.getActive().toast('Camera Kit and Filter Kit refreshed from Rig kit.');
}

function _rigkit_getRigSpecs_(rigSh) {
  const blocks = _rigkit_getBlocks_(rigSh);
  const nameRow = 3;
  const colorRow = 16;
  const flRow = findRowWithText_(rigSh, 'Effective focal length');
  const rigs = [];
  blocks.forEach(b => {
    const name = rigSh.getRange(nameRow, b.startCol).getDisplayValue().trim();
    if (!name || /^add rig/i.test(name)) return;
    let color = '';
    if (colorRow) {
      const colorCell = rigSh.getRange(colorRow, b.startCol);
      const bgColor = colorCell.getBackground();
      const textValue = colorCell.getDisplayValue().trim();
      if (bgColor && bgColor !== '#ffffff' && bgColor !== '#FFFFFF') {
        color = bgColor;
      } else if (textValue) {
        color = nameToHex_(textValue) || textValue;
      }
      if (!color) color = getHPC_Global_();
    }
    const fl = flRow ? Number(rigSh.getRange(flRow, b.startCol).getDisplayValue()) : NaN;
    rigs.push({ name, color, focalLengthMM: fl });
  });
  return rigs;
}

function _camerakit_getBlocks_(sh) {
  const width = getActiveWidth_(sh);
  const blocks = [];
  let c = 2;
  while (c <= width) {
    const cell = sh.getRange(3, c);
    const label = cell.getDisplayValue().trim();
    if (label && label.match(/^Camera\s+\d+$/)) {
      const m = cell.getMergedRanges();
      const w = (m && m.length) ? m[0].getWidth() : 2;
      blocks.push({ startCol: c, width: w });
      c += w;
    } else {
      break;
    }
  }
  return blocks;
}

function rebuildRigEligibility_Camera_Fixed_(camSh, rigs) {
  if (!camSh || !rigs || !rigs.length) return;
  const hpc = getHPC_Global_();
  const width = getActiveWidth_(camSh);
  let eligHeader = findRowWithText_(camSh, 'Rig Eligibility');
  if (!eligHeader) {
    const lastDataRow = Math.max(15, camSh.getLastRow());
    camSh.insertRowsAfter(lastDataRow, 1);
    eligHeader = lastDataRow + 1;
    mergeFullWidthRow_(camSh, eligHeader);
    camSh.getRange(eligHeader, 1).setValue('Rig Eligibility').setBackground(hpcShade(hpc, 40)).setFontSize(12).setFontWeight('bold').setFontColor(DARK_GREY_FONT).setHorizontalAlignment('center').setVerticalAlignment('middle');
  }
  const startRow = eligHeader + 1;
  const clearRows = Math.max(rigs.length * 3, 20);
  if (startRow + clearRows <= camSh.getMaxRows()) {
    camSh.getRange(startRow, 1, clearRows, width).clearContent().removeCheckboxes().setBackground(null).setFontWeight('normal').setFontColor('#000000');
  }
  const cameraBlocks = _camerakit_getBlocks_(camSh);
  rigs.forEach((rig, i) => {
    const tripletStart = startRow + (i * 3);
    const checkboxRow = tripletStart;
    const fovRow = tripletStart + 1;
    const scaleRow = tripletStart + 2;
    const rigColor = rig.color || hpc;
    const shadedColor = hpcShade(rigColor, 60);
    const fontColor = hexIsDark_(shadedColor) ? '#FFFFFF' : '#000000';
    camSh.getRange(checkboxRow, 1).setValue(rig.name).setFontWeight('normal');
    camSh.getRange(fovRow, 1).setValue('Field of View (arcminutes)').setFontWeight('normal');
    camSh.getRange(scaleRow, 1).setValue('Image Scale (arcsec/pixel)').setFontWeight('normal');
    camSh.getRange(checkboxRow, 1, 3, width).setBackground(shadedColor).setFontColor(fontColor);
    cameraBlocks.forEach(block => {
      camSh.getRange(checkboxRow, block.startCol, 1, block.width).merge().insertCheckboxes().setHorizontalAlignment('center').setVerticalAlignment('middle');
      camSh.getRange(fovRow, block.startCol, 1, block.width).merge().setValue('0').setHorizontalAlignment('center').setVerticalAlignment('middle');
      camSh.getRange(scaleRow, block.startCol, 1, block.width).merge().setValue('0').setHorizontalAlignment('center').setVerticalAlignment('middle');
    });
  });
}

function rebuildRigEligibility_Filter_Fixed_(filterSh, rigs) {
  if (!filterSh || !rigs || !rigs.length) return;
  const hpc = getHPC_Global_();
  const width = getActiveWidth_(filterSh);
  let eligHeader = findRowWithText_(filterSh, 'Rig Eligibility');
  if (!eligHeader) {
    const ackRow = findRowWithText_(filterSh, 'Acknowledge Defaults');
    if (ackRow) {
      filterSh.insertRowsAfter(ackRow, 2);
      eligHeader = ackRow + 2;
      mergeFullWidthRow_(filterSh, eligHeader);
      filterSh.getRange(eligHeader, 1).setValue('Rig Eligibility').setBackground(hpcShade(hpc, 40)).setFontSize(12).setFontWeight('bold').setFontColor(DARK_GREY_FONT).setHorizontalAlignment('center').setVerticalAlignment('middle');
    }
  }
  if (!eligHeader) return;
  const startRow = eligHeader + 1;
  const clearRows = Math.max(rigs.length + 5, 10);
  if (startRow + clearRows <= filterSh.getMaxRows()) {
    filterSh.getRange(startRow, 1, clearRows, width).clearContent().removeCheckboxes().setBackground(null).setFontWeight('normal').setFontColor('#000000');
  }
  const filterBlocks = getFilterBlocks_(filterSh);
  rigs.forEach((rig, i) => {
    const row = startRow + i;
    const rigColor = rig.color || hpc;
    const shadedColor = hpcShade(rigColor, 60);
    const fontColor = hexIsDark_(shadedColor) ? '#FFFFFF' : '#000000';
    leftLabel_(filterSh.getRange(row, 1)).setValue(rig.name);
    filterSh.getRange(row, 1, 1, width).setBackground(shadedColor).setFontColor(fontColor);
    filterBlocks.forEach(block => {
      filterSh.getRange(row, block.startCol, 1, block.width).merge().insertCheckboxes().setHorizontalAlignment('center').setVerticalAlignment('middle');
    });
  });
}

function updateAllRigAirQuality() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  const pairs = getPairsFromHeaders_(sh);
  if (pairs.length === 0) return;
  const airQualityRow = findRowWithText_(sh, 'Air quality index');
  if (!airQualityRow) return;
  pairs.forEach(([cL, cR]) => {
    const lat = sh.getRange(9, cL).getValue();
    const lon = sh.getRange(10, cL).getValue();
    if (lat && lon) {
      try {
        const aqi = getAirQualityIndex(lat, lon);
        if (aqi !== null) { sh.getRange(airQualityRow, cL, 1, 2).setValue(aqi); }
      } catch (e) { console.log(`Air quality lookup failed for rig at ${lat}, ${lon}: ${e.message}`); }
    }
  });
  SpreadsheetApp.getActive().toast('Air quality data updated for all rigs');
}

function updateAllRigBortleClass() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  const pairs = getPairsFromHeaders_(sh);
  if (pairs.length === 0) return;
  const skyBrightnessRow = findRowWithText_(sh, 'Sky Brightness');
  if (!skyBrightnessRow) return;
  pairs.forEach(([cL, cR]) => {
    const lat = sh.getRange(9, cL).getValue();
    const lon = sh.getRange(10, cL).getValue();
    if (lat && lon) {
      try {
        const bortle = getBortleClass(lat, lon);
        if (bortle !== null) { sh.getRange(skyBrightnessRow, cL, 1, 2).setValue(bortle); }
      } catch (e) { console.log(`Bortle class lookup failed for rig at ${lat}, ${lon}: ${e.message}`); }
    }
  });
  SpreadsheetApp.getActive().toast('Sky brightness data updated for all rigs');
}

function getAirQualityIndex(lat, lon) {
  const { airNowApiKey } = getSkyPixConfig();
  if (!airNowApiKey) return null;
  try {
    const url = `https://www.airnowapi.org/aq/observation/latLong/current/?format=application/json&latitude=${lat}&longitude=${lon}&distance=50&API_KEY=${airNowApiKey}`;
    const response = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    const data = JSON.parse(response.getContentText());
    if (response.getResponseCode() === 200 && data.length > 0) { return data[0].AQI || null; }
  } catch (e) { console.log('Air quality API error:', e.message); }
  return null;
}

function getBortleClass(lat, lon) { return 'Class 4-5'; }

function rigkit_applyZenithLandscapeLayout_(sh) {
  if (!sh) return;
  const pairs = getPairsFromHeaders_(sh);
  let zenithRow = findRowWithText_(sh, 'Zenith Obstruction');
  if (zenithRow) {
    pairs.forEach(([cL, cR]) => {
      for (let i = 1; i <= 3; i++) {
        const row = zenithRow + i;
        sh.getRange(row, cL).setValue('Az');
        sh.getRange(row, cR).setValue('Alt');
      }
    });
  }
  let horizonRow = getLandHdrRow_(sh);
  if (horizonRow) {
    pairs.forEach(([cL, cR]) => {
      sh.getRange(horizonRow + 1, cL).setValue('Az');
      sh.getRange(horizonRow + 1, cR).setValue('Alt');
      for (let i = 2; i <= 10; i++) {
        sh.getRange(horizonRow + i, cL).setValue('');
        sh.getRange(horizonRow + i, cR).setValue('');
      }
    });
  }
}

function rebuildRigEligibility_Camera_() {
  const ss = SpreadsheetApp.getActive();
  const rigSheet = ss.getSheetByName('Rig kit');
  if (!rigSheet) return;
  const rigs = _rigkit_getRigSpecs_(rigSheet);
  const ck = ss.getSheetByName(CK.NAME);
  if (ck) rebuildRigEligibility_Camera_Fixed_(ck, rigs);
  const fk = ss.getSheetByName(FK.NAME);
  if (fk) rebuildRigEligibility_Filter_Fixed_(fk, rigs);
  ss.toast('Camera/Filter kits refreshed from Rig kit.');
}

function rebuildRigEligibility_Filter_() {
  const ss = SpreadsheetApp.getActive();
  const rigData = getRigData_();
  const filterBlocks = getFilterBlocks_(ss.getSheetByName(FK.NAME));
  rebuildRigEligibility_Filter_(rigData, filterBlocks);
}

// ======================= CAMERA KIT RIG ELIGIBILITY =======================

function rebuildCameraRigEligibility_(camSh, rigs) {
  if (!camSh || !rigs || !rigs.length) return;

  const hpc = getHPC_Global_();
  const width = getActiveWidth_(camSh);
  
  let ackRow = findRowWithText_(camSh, 'Acknowledge Defaults');
  if (!ackRow) {
    const lastRow = Math.max(14, camSh.getLastRow());
    camSh.insertRowsAfter(lastRow, 1);
    ackRow = lastRow + 1;
    leftLabel_(camSh.getRange(ackRow, 1)).setValue('Acknowledge Defaults').setFontSize(10).setFontWeight('normal');
    if (width > 1) {
      camSh.getRange(ackRow, 2, 1, width - 1).merge().insertCheckboxes().setHorizontalAlignment('center');
    }
  }

  const blankRow = ackRow + 1;
  if (blankRow + 2 > camSh.getMaxRows()) {
    camSh.insertRowsAfter(camSh.getMaxRows(), 3);
  }
  mergeFullWidthRow_(camSh, blankRow);
  camSh.getRange(blankRow, 1).setValue('').setBackground(null);

  const eligHeader = blankRow + 1;
  mergeFullWidthRow_(camSh, eligHeader);
  camSh.getRange(eligHeader, 1).setValue('Rig Eligibility')
        .setBackground(hpcShade(hpc, 40))
        .setFontSize(12)
        .setFontWeight('bold')
        .setFontColor(DARK_GREY_FONT)
        .setHorizontalAlignment('center')
        .setVerticalAlignment('middle');

  const startRow = eligHeader + 1;
  
  const clearRows = Math.max(rigs.length * 3, 15);
  if (startRow + clearRows <= camSh.getMaxRows()) {
    camSh.getRange(startRow, 1, clearRows, width)
        .clearContent()
        .removeCheckboxes()
        .setBackground(null)
        .setFontWeight('normal')
        .setFontColor('#000000');
  }

  const cameraBlocks = _camerakit_getBlocks_(camSh);

  rigs.forEach((rig, i) => {
    const tripletStart = startRow + (i * 3);
    const checkboxRow = tripletStart;
    const fovRow = tripletStart + 1;
    const scaleRow = tripletStart + 2;
    
    camSh.setRowHeight(checkboxRow, 36);
    camSh.setRowHeight(fovRow, 36);
    camSh.setRowHeight(scaleRow, 36);
    
    const rigColor = rig.color || hpc;
    const shadedColor = hpcShade(rigColor, 30);
    const fontColor = hexIsDark_(shadedColor) ? '#FFFFFF' : '#000000';

    camSh.getRange(checkboxRow, 1).setValue(rig.name).setFontWeight('normal');
    camSh.getRange(fovRow, 1).setValue('Field of View\n(arcminutes)').setFontWeight('normal').setWrap(true).setHorizontalAlignment('right');
    camSh.getRange(scaleRow, 1).setValue('Image Scale\n(arcsec/pixel)').setFontWeight('normal').setWrap(true).setHorizontalAlignment('right');
    
    camSh.getRange(checkboxRow, 1, 3, width)
        .setBackground(shadedColor)
        .setFontColor(fontColor);

    cameraBlocks.forEach(block => {
      camSh.getRange(checkboxRow, block.startCol, 1, block.width)
          .merge()
          .insertCheckboxes()
          .setHorizontalAlignment('center')
          .setVerticalAlignment('middle');

      camSh.getRange(fovRow, block.startCol, 1, block.width)
          .merge()
          .setValue('0')
          .setHorizontalAlignment('right')
          .setVerticalAlignment('middle')
          .setWrap(true);
          
      camSh.getRange(scaleRow, block.startCol, 1, block.width)
          .merge()
          .setValue('0')
          .setHorizontalAlignment('right')
          .setVerticalAlignment('middle')
          .setWrap(true);
    });
  });
}

function _camerakit_getBlocks_(sh) {
  const width = getActiveWidth_(sh);
  const blocks = [];
  let c = 2;
  while (c <= width) {
    const cell = sh.getRange(3, c);
    const label = cell.getDisplayValue().trim();
    if (label && label.match(/^Camera\s+\d+$/)) {
      const m = cell.getMergedRanges();
      const w = (m && m.length) ? m[0].getWidth() : 2;
      blocks.push({ startCol: c, width: w });
      c += w;
    } else {
      break;
    }
  }
  return blocks;
}

// ======================= FILTER KIT RIG ELIGIBILITY =======================

function rebuildFilterRigEligibility_(filterSh, rigs) {
  let startRow = 15;
  
  const maxRows = filterSh.getMaxRows();
  if (startRow < maxRows) {
    filterSh.deleteRows(startRow + 3, maxRows - startRow - 2);
  }
  
  leftLabel_(filterSh.getRange(startRow, 1)).setValue('Acknowledge Defaults');
  
  filterSh.getRange(startRow + 1, 1).setValue('').setBackground(hpcShade(getHPC_Global_(), 40));
  
  filterSh.getRange(startRow + 2, 1).setValue('Rig Eligibility').setBackground(hpcShade(getHPC_Global_(), 40));
  styleSubheader_(filterSh.getRange(startRow + 2, 1), DARK_GREY_FONT);
  
  let currentRow = startRow + 3;
  rigs.forEach(rig => {
    const rigRange = filterSh.getRange(currentRow, rig.column, 1, 2);
    rigRange.setBackground(hpcShade(rig.color, 30));
    rigRange.insertCheckboxes().setValue(false);
    rigRange.setVerticalAlignment('middle').setHorizontalAlignment('center');
    
    currentRow += 1;
  });
  
  rigs.forEach(rig => {
    filterSh.getRange(startRow, rig.column, 1, 2).insertCheckboxes().setValue(false);
  });
}

// ======================= AIR QUALITY AND BORTLE CLASS FUNCTIONS =======================

function updateAllRigAirQuality() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;

  const pairs = getPairsFromHeaders_(sh);
  if (pairs.length === 0) return;

  const airQualityRow = findRowWithText_(sh, 'Air quality index');
  if (!airQualityRow) return;

  pairs.forEach(([cL, cR]) => {
    const lat = sh.getRange(9, cL).getValue();
    const lon = sh.getRange(10, cL).getValue();
    
    if (lat && lon) {
      try {
        const aqi = getAirQualityIndex(lat, lon);
        if (aqi !== null) {
          sh.getRange(airQualityRow, cL, 1, 2).setValue(aqi);
        }
      } catch (e) {
        console.log(`Air quality lookup failed for rig at ${lat}, ${lon}: ${e.message}`);
      }
    }
  });

  SpreadsheetApp.getActive().toast('Air quality data updated for all rigs');
}

function updateAllRigBortleClass() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;

  const pairs = getPairsFromHeaders_(sh);
  if (pairs.length === 0) return;

  const skyBrightnessRow = findRowWithText_(sh, 'Sky Brightness');
  if (!skyBrightnessRow) return;

  pairs.forEach(([cL, cR]) => {
    const lat = sh.getRange(9, cL).getValue();
    const lon = sh.getRange(10, cL).getValue();
    
    if (lat && lon) {
      try {
        const bortle = getBortleClass(lat, lon);
        if (bortle !== null) {
          sh.getRange(skyBrightnessRow, cL, 1, 2).setValue(bortle);
        }
      } catch (e) {
        console.log(`Bortle class lookup failed for rig at ${lat}, ${lon}: ${e.message}`);
      }
    }
  });

  SpreadsheetApp.getActive().toast('Sky brightness data updated for all rigs');
}

function getAirQualityIndex(lat, lon) {
  const { airNowApiKey } = getSkyPixConfig();
  if (!airNowApiKey) return null;
  
  try {
    const url = `https://www.airnowapi.org/aq/observation/latLong/current/?format=application/json&latitude=${lat}&longitude=${lon}&distance=50&API_KEY=${airNowApiKey}`;
    const response = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    const data = JSON.parse(response.getContentText());
    
    if (response.getResponseCode() === 200 && data.length > 0) {
      return data[0].AQI || null;
    }
  } catch (e) {
    console.log('Air quality API error:', e.message);
  }
  
  return null;
}

function getBortleClass(lat, lon) {
  return 'Class 4-5'; // Suburban/Rural transition
}

function rigkit_applyZenithLandscapeLayout_(sh) {
  if (!sh) return;
  
  const width = getActiveWidth_(sh);
  const pairs = getPairsFromHeaders_(sh);
  
  let zenithRow = findRowWithText_(sh, 'Zenith Obstruction');
  if (zenithRow) {
    pairs.forEach(([cL, cR]) => {
      for (let i = 1; i <= 3; i++) {
        const row = zenithRow + i;
        sh.getRange(row, cL).setValue('Az');
        sh.getRange(row, cR).setValue('Alt');
      }
    });
  }
  
  let horizonRow = getLandHdrRow_(sh);
  if (horizonRow) {
    pairs.forEach(([cL, cR]) => {
      sh.getRange(horizonRow + 1, cL).setValue('Az');
      sh.getRange(horizonRow + 1, cR).setValue('Alt');
      for (let i = 2; i <= 10; i++) {
        sh.getRange(horizonRow + i, cL).setValue('');
        sh.getRange(horizonRow + i, cR).setValue('');
      }
    });
  }
}

function rigkit_resetRefreshBar_(sh) {
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_RIG);
}

function rebuildRigEligibility_Camera_() {
  const ss = SpreadsheetApp.getActive();
  rebuildRigEligibility_Camera_();
  rebuildRigEligibility_Filter_();

  const ck = ss.getSheetByName(CK.NAME);
  if (ck) recolorCameraKitBands_(ck);
  const fk = ss.getSheetByName(FK.NAME);
  if (fk) recolorFilterKitBands_(fk);

  ss.toast('Camera/Filter kits refreshed from Rig kit.');
}

function rebuildRigEligibility_Filter_() {
  const ss = SpreadsheetApp.getActive();
  
  const rigData = getRigData_();
  const filterBlocks = getFilterBlocks_(ss.getSheetByName(FK.NAME));
  rebuildRigEligibility_Filter_(rigData, filterBlocks);
}

function rigkit_forceColorPicker_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Rig kit');
  if (!sh) { ss.toast('Rig kit sheet not found.'); return; }

  const colorRow = findRowWithText_(sh, 'Rig highlight color');
  if (!colorRow) { SpreadsheetApp.getUi().alert('"Rig highlight color" row not found.'); return; }

  const names = COLOR_PICKER.map(r => r[0]);
  const dv = SpreadsheetApp.newDataValidation()
    .requireValueInList(names, true)
    .setAllowInvalid(true)
    .build();

  const pairs = getPairsFromHeaders_(sh);
  pairs.forEach(([cL]) => {
    try { sh.getRange(colorRow, cL, 1, 2).breakApart(); } catch(e){}
    sh.getRange(colorRow, cL, 1, 2).merge().setDataValidation(dv);
  });

  ss.toast('Rig color picker restored.');
}

// ======================= Camera Kit Module ============================== //

const CK_LABELS = [ 'Camera Model', 'Pixel Size (um)', 'Sensor size (pixels)', 'Quantum Efficiency (%)', 'Read Noise (e-)', 'Dark Current (e-/s)', 'Full Well Capacity (e-)', 'Cooling Delta (degC)', 'Optimal Gain', 'Camera Highlight Color' ];
const CK = { NAME: 'Camera Kit', LABEL_START: 4, ELIG_START_ROW: 16, ROWS: { COLOR: 13 }};
// Extend Camera Kit rows for the Rig Eligibility triplets
CK.ROWS = Object.assign({}, CK.ROWS, {
  ACK: 15,       // "Acknowledge Defaults" row
  BLANK: 16,     // dynamic spacer row under ACK
  RIG_HDR: 17    // "Rig Eligibility" header row
});


function buildCameraKit_(ss) {
  const sh = ss.getSheetByName(CK.NAME) || ss.insertSheet(CK.NAME, 3);
  sh.clear(); sh.setName(CK.NAME);
  while (sh.getMaxColumns() < 4) sh.insertColumnAfter(sh.getMaxColumns());
  sh.setColumnWidth(1, 160).setColumnWidths(2, sh.getMaxColumns()-1, 55);
  
  sh.setRowHeights(1, 3, 36);
  sh.setRowHeights(4, sh.getMaxRows()-3, ROW_H_ALL);
  
  sh.insertRowAfter(13);
  mergeFullWidthRow_(sh, 14);
  mergeFullWidthRow_(sh, 1);
  mergeFullWidthRow_(sh, 15);

  sh.getRange('A1').setValue('Camera Kit');
  sh.getRange('A15').setValue('Rig Eligibility');
  sh.getRange('A3').setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(['Add Camera', 'Cancel'], true).setAllowInvalid(true).build());
  sh.getRange('B3:C3').merge().setValue('Camera 1');
  
  CK_LABELS.forEach((label, i) => {
    leftLabel_(sh.getRange(CK.LABEL_START + i, 1)).setValue(label).setWrap(true);
  });
  
  sh.getRange(13, 2, 1, getActiveWidth_(sh) - 1).setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(COLOR_PICKER.map(r=>r[0]),true).setAllowInvalid(true).build());

  center_(sh.getRange(6, 2)).setValue('Width').setFontSize(10);
  center_(sh.getRange(6, 3)).setValue('Height').setFontSize(10);
  
  sh.getRange('B4:C13').setHorizontalAlignment('center').setVerticalAlignment('middle');
  sh.getRange(4, 2, 1, 2).setWrap(true);
  
  applyCameraPairMerges_(sh, 2);
  
  sh.getRange(CK.LABEL_START, 2, 9, 2).setBackground(WARN_YELLOW);
  const v = SpreadsheetApp.newDataValidation;
  sh.getRange(CK.LABEL_START + 1, 2, 1, 2).setDataValidation(v().requireNumberBetween(1.0, 15.0).setAllowInvalid(true).build());
  sh.getRange(CK.LABEL_START + 2, 2, 1, 2).setDataValidation(v().requireNumberGreaterThan(0).setAllowInvalid(true).build());
  sh.getRange(CK.LABEL_START + 3, 2, 1, 2).setDataValidation(v().requireNumberBetween(20, 99).setAllowInvalid(true).build());
  sh.getRange(CK.LABEL_START + 4, 2, 1, 2).setDataValidation(v().requireNumberBetween(0.2, 20.0).setAllowInvalid(true).build());
  sh.getRange(CK.LABEL_START + 5, 2, 1, 2).setDataValidation(v().requireNumberBetween(0, 4.0).setAllowInvalid(true).build());
  sh.getRange(CK.LABEL_START + 6, 2, 1, 2).setDataValidation(v().requireNumberGreaterThan(1000).setAllowInvalid(true).build());
  sh.getRange(CK.LABEL_START + 7, 2, 1, 2).setDataValidation(v().requireNumberBetween(-60, 0).setAllowInvalid(true).build());
  sh.getRange(CK.LABEL_START + 8, 2, 1, 2).setDataValidation(v().requireNumberGreaterThanOrEqualTo(0).setAllowInvalid(true).build());

  sh.setFrozenRows(3);
  recolorCameraKitBands_(sh);
  rebuildRigEligibility_Camera_();
  camera_autoPatch_();
  camera_fixLayout_();
  camerakit_normalizeNow_();  // <- keep merges, colors, helpers, and checkboxes correct
}

function applyCameraPairMerges_(sh, cL) {
    [4, 5, 7, 8, 9, 10, 11, 12, 13].forEach(r => {
        try { sh.getRange(r, cL, 1, 2).merge(); } catch(e){}
    });
}

function rebuildCameraKitFormatting_() {
    const sh = SpreadsheetApp.getActive().getSheetByName(CK.NAME);
    if (!sh) return;
    mergeFullWidthRow_(sh, 1);
    mergeFullWidthRow_(sh, 14);
    mergeFullWidthRow_(sh, 15);
    recolorCameraKitBands_(sh);
    rebuildRigEligibility_Camera_();
}
function recolorCameraKitBands_(sh) {
  if (!sh) return;
  const hpc = getHPC_Global_();
  const width = getActiveWidth_(sh);

  const title = sh.getRange(1, 1, 1, width).merge().setBackground(hpcShade(hpc, 80));
  styleSubheader_(title, '#FFFFFF').setFontSize(TITLE_FS);
  
  const eligHeader = sh.getRange(15, 1, 1, width).merge().setBackground(hpcShade(hpc, 40));
  styleSubheader_(eligHeader, DARK_GREY_FONT);

  const addCell = sh.getRange('A3');
  const addBg = hpcShade(hpc, 20);
  addCell.setBackground(addBg);
  styleSubheader_(addCell, '#FFFFFF');
  stylePaddedCell_(addCell, 'Add Camera...', addBg, '#FFFFFF', true);

  const cameraHeaders = sh.getRange(3, 2, 1, width - 1).setBackground(hpcShade(hpc, 40));
  styleSubheader_(cameraHeaders, '#FFFFFF');
  
  sh.getRange(1, 1, sh.getFrozenRows(), width).setBorder(true, true, true, true, null, true, hpcShade(hpc, 40), SpreadsheetApp.BorderStyle.SOLID);
  
  // Corrected typo on this line:
  writeRefreshLabel_(SpreadsheetApp.getActive().getSheetByName('Camera Kit'), REFRESH_NEUTRAL_BG, REFRESH_CHOICES_CAMERA);
  camerakit_rebuildRigEligibility_(SpreadsheetApp.getActive().getSheetByName(CK.NAME || 'Camera Kit'));
}

function SkyPix_AddCamera_(command) {
  const sh = SpreadsheetApp.getActive().getSheetByName('Camera Kit');
  if (!sh) return;

  const startCol   = getActiveWidth_(sh) + 1;
  const blockWidth = 2;

  // Insert the 2-col camera block and match width to col B
  sh.insertColumnsAfter(startCol - 1, blockWidth);
  try {
    const w = sh.getColumnWidth(2);
    sh.setColumnWidths(startCol, blockWidth, w);
  } catch (_) {}

  // Title "Camera N" over the 2 new columns (row 3)
  const existing = sh.getRange(3, 2, 1, Math.max(0, startCol - 2)).getDisplayValues()[0]
    .filter(v => (v || '').toString().trim());
  const nextNum = (existing.filter(v => /^Camera\s+\d+$/i.test(v)).length || 0) + 1;
  try {
    sh.getRange(3, startCol, 1, blockWidth)
      .merge()
      .setValue(`Camera ${nextNum}`)
      .setHorizontalAlignment('center')
      .setVerticalAlignment('middle')
      .setFontWeight('bold');
  } catch (_) {}

  // Repair merges/labels/pickers and keep your band colors
  camerakit_fixLayout_(sh);
  try { recolorCameraKitBands_ && recolorCameraKitBands_(sh); } catch (_) {}

  SpreadsheetApp.getActive().toast('Camera added.');
  camerakit_normalizeNow_();
  camerakit_rebuildRigEligibility_(sh);
}


function getRigDataForCalculations_() {
  const rigSheet = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!rigSheet) return [];
  const rigData = getRigData_(); 
  
  const flRow = findRowWithText_(rigSheet, 'Effective focal length (mm)');
  if (!flRow) return rigData;

  const focalLengths = rigSheet.getRange(flRow, 2, 1, getActiveWidth_(rigSheet) - 1).getValues()[0];
  
  return rigData.map((rig, i) => {
    rig.focalLength = parseFloat(focalLengths[i * 2]) || 0;
    return rig;
  });
}

function getCameraDataForCalculations_() {
  const cameraSheet = SpreadsheetApp.getActive().getSheetByName(CK.NAME);
  if (!cameraSheet) return [];
  const pairs = getPairsFromHeaders_(cameraSheet);
  if (pairs.length === 0) return [];

  const data = cameraSheet.getRange(CK.LABEL_START, 2, 3, cameraSheet.getLastColumn() - 1).getValues();

  return pairs.map(([cL, cR]) => {
    const colIndex = cL - 2;
    return {
      pixelSize: parseFloat(data[1][colIndex]) || 0,
      sensorWidth: parseFloat(data[2][colIndex]) || 0,
      sensorHeight: parseFloat(data[2][colIndex + 1]) || 0
    };
  });
}

function rebuildRigEligibility_Camera_() {
  const ss = SpreadsheetApp.getActive();
  const cameraSheet = ss.getSheetByName(CK.NAME);
  if (!cameraSheet) return;

  const startRow = CK.ELIG_START_ROW;
  if (cameraSheet.getLastRow() >= startRow) {
    cameraSheet.deleteRows(startRow, cameraSheet.getLastRow() - startRow + 1);
  }

  const rigs = getRigDataForCalculations_();
  const cameras = getCameraDataForCalculations_();
  if (rigs.length === 0 || cameras.length === 0) return;

  cameraSheet.insertRowsAfter(startRow - 1, rigs.length * 3);
  const activeWidth = getActiveWidth_(cameraSheet);
  const cameraPairs = getPairsFromHeaders_(cameraSheet);

  rigs.forEach((rig, i) => {
    const row = startRow + (i * 3);
    const rigBand = cameraSheet.getRange(row, 1, 3, activeWidth);
    const rigHex = normalizeHexOrName_(rig.color);
if (rigHex) {
  // Shade a bit so checkboxes/text are readable
  const band = cameraSheet.getRange(row, 1, 3, activeWidth);
  band.setBackground(hpcShade(rigHex, 40))
      .setFontColor(DARK_GREY_FONT);
}

    
    leftLabel_(cameraSheet.getRange(row, 1)).setValue(rig.name);
    rightLabel_(cameraSheet.getRange(row + 1, 1)).setValue('Field of View\n(arcminutes)');
    rightLabel_(cameraSheet.getRange(row + 2, 1)).setValue('Image Scale\n(arcsec/pixel)');
    
    cameraPairs.forEach(([cL, cR], j) => {
      cameraSheet.getRange(row, cL, 1, 2).merge().insertCheckboxes();
      
      const cam = cameras[j];
      let imageScale = (cam.pixelSize > 0 && rig.focalLength > 0) ? 206.265 * (cam.pixelSize / rig.focalLength) : 0;
      cameraSheet.getRange(row + 2, cL, 1, 2).merge().setValue(imageScale.toFixed(2));

      let fovWidth = imageScale > 0 ? (cam.sensorWidth * imageScale) / 60 : 0;
      let fovHeight = imageScale > 0 ? (cam.sensorHeight * imageScale) / 60 : 0;
      cameraSheet.getRange(row + 1, cL).setValue(fovWidth.toFixed(2));
      cameraSheet.getRange(row + 1, cR).setValue(fovHeight.toFixed(2));
      
      cameraSheet.getRange(row, cL, 3, 2).setBorder(null, true, null, true, false, false, '#D9D9D9', SpreadsheetApp.BorderStyle.SOLID);
    });
  });
}

/***** CAMERA KIT PATCH — sensor row, ack row, rig sync, normal fonts, refresh label *****/

/** Make sure a "Sensor Model" row exists right under "Camera Model". */
function camera_ensureSensorModelRow_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Camera Kit');
  if (!sh) return;
  const camModelRow = findRowWithText_(sh, 'Camera Model');
  if (!camModelRow) return;

  const nextLabel = (sh.getRange(camModelRow + 1, 1).getDisplayValue() || '').trim();
  if (nextLabel !== 'Sensor Model') {
    sh.insertRowsAfter(camModelRow, 1);
    sh.getRange(camModelRow + 1, 1).setValue('Sensor Model').setFontWeight('bold');
    const width = Math.max(2, getActiveWidth_(sh));
    if (width >= 2) {
      // keep value cells “input yellow”
      sh.getRange(camModelRow + 1, 2, 1, width - 1).setBackground('#FFF2CC');
    }
  }
}

/** Insert "Acknowledge Defaults" just above "Rig Eligibility", with a blank spacer below. */
function camera_putAckDefaultsRow_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Camera Kit');
  if (!sh) return;
  const rigHdr = findRowWithText_(sh, 'Rig Eligibility');
  if (!rigHdr) return;

  // We want: [Ack row], [blank spacer], then the Rig Eligibility header
  const maybeAckRow = rigHdr - 2;
  const haveAck = (sh.getRange(maybeAckRow, 1).getDisplayValue() || '').trim() === 'Acknowledge Defaults';

  if (!haveAck) {
    sh.insertRowsBefore(rigHdr, 2);
    const ackRow = rigHdr; // header moved down by 2
    sh.getRange(ackRow, 1).setValue('Acknowledge Defaults').setFontWeight('bold');

    const width = Math.max(2, getActiveWidth_(sh));
    const boxRange = width >= 2 ? sh.getRange(ackRow, 2, 1, width - 1) : sh.getRange(ackRow, 2);
    boxRange.merge().insertCheckboxes().setHorizontalAlignment('center');
    // spacer row below is left empty by design
  }
}

/** Rebuild the Camera-Kit “Rig Eligibility” from Rig kit (names + colors), normal font. */
function camera_syncRigs_() {
  const cam = SpreadsheetApp.getActive().getSheetByName('Camera Kit');
  const rig = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!cam || !rig) return;

  const rigHdr = findRowWithText_(cam, 'Rig Eligibility');
  if (!rigHdr) return;

  const width = Math.max(2, getActiveWidth_(cam));
  const pairs = getPairsFromHeaders_(rig); // your existing helper that returns [cL,cR] per rig

  const colorRow = findRowWithText_(rig, 'Rig highlight color');
  const rowsToClear = 50; // generous
  cam.getRange(rigHdr + 1, 1, rowsToClear, width).clearContent().clearFormat();

  let row = rigHdr + 1;
  pairs.forEach(([cL /*, cR*/]) => {
    const name = rig.getRange(3, cL).getDisplayValue().trim();
    if (!name) return;

    // label, normal font
    cam.getRange(row, 1).setValue(name).setFontWeight('normal');

    // checkbox merged across camera columns
    const cell = width >= 2 ? cam.getRange(row, 2, 1, width - 1) : cam.getRange(row, 2);
    cell.merge().insertCheckboxes().setHorizontalAlignment('center');

    // apply rig color wash if set
    let hex = '';
    if (colorRow) hex = nameToHex_(rig.getRange(colorRow, cL).getDisplayValue()) || '';
    if (hex) {
      cam.getRange(row, 1, 1, width)
        .setBackground(hex)
        .setFontColor(hexIsDark_(hex) ? '#FFFFFF' : '#000000');
    }
    row++;
  });
}

/** One-time “apply” entry point you can run from the Apps Script Run menu. */
function camera_applyPatchNow() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Camera Kit');
  camera_ensureSensorModelRow_();
  camera_putAckDefaultsRow_();
  camera_syncRigs_();
  if (sh) {
    // Show the correct refresh choices on the bar
    writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, ['Refresh planner', 'Retrieve specifications', 'Cancel']);
  }
  SpreadsheetApp.getActive().toast('Camera Kit patched.');
}

/***** CAMERA KIT — layout + picker + refresh (idempotent) *****/
function camera_fixLayout_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Camera Kit');
  if (!sh) return;

  // Helpers
  const width = getActiveWidth_(sh);
  const firstDataCol = 2; // B
  const lastDataCol  = Math.max(width, firstDataCol);
  function colPairStartCols_() {
    const starts = [];
    for (let c = firstDataCol; c <= lastDataCol; c += 2) starts.push(c);
    return starts;
  }
  function mergePairsInRow_(row) {
    colPairStartCols_().forEach(c => {
      const r = sh.getRange(row, c, 1, Math.min(2, sh.getMaxColumns() - c + 1));
      try { r.merge(); } catch(e) {}
    });
  }
  function yellow_(r) { r.setBackground('#fff2cc'); }        // entry cells
  function orange_(r) { r.setBackground('#f4b183'); }        // fetched cells
  function normalFontRow_(row){ sh.getRange(row, 1, 1, lastDataCol).setFontWeight('normal'); }

  // --- Ensure "Sensor Model" row exists under "Camera Model", pair-merged & yellow
  const camRow  = findRowWithText_(sh, 'Camera Model');
  let   sensRow = findRowWithText_(sh, 'Sensor Model');
  if (camRow) {
    if (!sensRow || sensRow !== camRow + 1) {
      // Insert or move so it sits exactly under Camera Model
      if (!sensRow) {
        sh.insertRowsAfter(camRow, 1);
        sh.getRange(camRow + 1, 1).setValue('Sensor Model');
        sensRow = camRow + 1;
      } else if (sensRow !== camRow + 1) {
        const values = sh.getRange(sensRow, 1, 1, lastDataCol).getValues();
        sh.deleteRow(sensRow);
        sh.insertRowsAfter(camRow, 1);
        sh.getRange(camRow + 1, 1, 1, lastDataCol).setValues(values);
        sensRow = camRow + 1;
      }
    }
    mergePairsInRow_(sensRow);
    yellow_(sh.getRange(sensRow, firstDataCol, 1, lastDataCol - firstDataCol + 1));
  }

  // --- Keep Pixel Size and Sensor size sub-headers pair-aligned (Width/Height)
  const pixRow = findRowWithText_(sh, 'Pixel Size (um)');
  if (pixRow) {
    // Put sub-headers in the first visible pair and copy across
    sh.getRange(pixRow, firstDataCol, 1, 1).setValue('Width');
    sh.getRange(pixRow, firstDataCol + 1, 1, 1).setValue('Height');
    colPairStartCols_().forEach(c => {
      sh.getRange(pixRow, c, 1, 1).setValue('Width');
      sh.getRange(pixRow, c + 1, 1, 1).setValue('Height');
    });
  }
  const sensSizeRow = findRowWithText_(sh, 'Sensor size (pixels)');
  if (sensSizeRow) {
    colPairStartCols_().forEach(c => {
      sh.getRange(sensSizeRow, c, 1, 1).setValue('Width');
      sh.getRange(sensSizeRow, c + 1, 1, 1).setValue('Height');
    });
  }

  // --- "Camera Highlight Color" row: dropdown + live color (no onEdit needed)
  const colorRow = findRowWithText_(sh, 'Camera Highlight Color');
  if (colorRow) {
    const dv = SpreadsheetApp.newDataValidation()
      .requireValueInList(COLOR_PICKER.map(r => r[0]), true)
      .setAllowInvalid(true)
      .build();
    sh.getRange(colorRow, firstDataCol, 1, lastDataCol - firstDataCol + 1).setDataValidation(dv);

    // Conditional-formatting rules so the cell paints itself to the picked color
    const rules = sh.getConditionalFormatRules();
    // Remove old rules that target this row to avoid duplicates
    const filtered = rules.filter(r => {
      const rgns = r.getRanges();
      return !rgns.some(g =>
        g.getRow() === colorRow && g.getNumRows() === 1 &&
        g.getColumn() <= lastDataCol && (g.getColumn() + g.getNumColumns() - 1) >= firstDataCol
      );
    });
    const target = sh.getRange(colorRow, firstDataCol, 1, lastDataCol - firstDataCol + 1);
    COLOR_PICKER.forEach(([name, hex]) => {
      filtered.push(
        SpreadsheetApp.newConditionalFormatRule()
          .whenTextEqualTo(name)
          .setBackground(hex)
          .setFontColor(hexIsDark_(nameToHex_(name)) ? '#FFFFFF' : '#000000')
          .setRanges([target])
          .build()
      );
    });
    sh.setConditionalFormatRules(filtered);
  }

  // --- "Acknowledge Defaults" row: pair-merge across each camera
  const ackRow = findRowWithText_(sh, 'Acknowledge Defaults');
  if (ackRow) {
    mergePairsInRow_(ackRow);
  }

  // --- Rig Eligibility block: keep text normal (not bold) and preserve spacing
  const eligHeader = findRowWithText_(sh, 'Rig Eligibility');
  if (eligHeader) {
    normalFontRow_(eligHeader + 1);
    normalFontRow_(eligHeader + 2);
    normalFontRow_(eligHeader + 3);
  }

  // --- Refresh bar choices for Camera Kit
  camera_setRefreshChoices_();
}

function camera_setRefreshChoices_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Camera Kit');
  if (!sh) return;
  // Same look as other sheets; choices per spec.
  if (typeof writeRefreshLabel_ === 'function') {
    writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, ['Refresh planner', 'Retrieve specifications', 'Cancel']);
  } else {
    // fallback: write plain text if helper not present
    sh.getRange(2, 2).setValue('Refresh');
  }
}

// --- Camera Kit layout repair & color picker helpers ------------------------

function centerSafe_(range) {
  try { return center_(range); } catch (_) {
    return range.setHorizontalAlignment('center').setVerticalAlignment('middle');
  }
}

// Re-merge, re-label and re-apply validations after any camera is added
function camerakit_fixLayout_(sh) {
  if (!sh || sh.getName() !== 'Camera Kit') return;

  const width = getActiveWidth_(sh);
  if (width < 2) return;

  // Merge top bands full width
  try { sh.getRange(1, 1, 1, width).merge(); } catch (_) {}
  try { sh.getRange(2, 1, 1, width).merge(); } catch (_) {}

  // Find section rows by text (robust to future inserts)
  const RE_HDR  = findRowWithText_(sh, 'Rig Eligibility') || 16;
  const FOV_ROW = findRowWithText_(sh, 'Field of View')   || (RE_HDR + 1);
  const IMG_ROW = findRowWithText_(sh, 'Image Scale')     || (RE_HDR + 2);

  try { sh.getRange(RE_HDR, 1, 1, width).merge(); } catch (_) {}

  // Use the bright entry yellow from Pixel Size (row 6, col B)
  let entryYellow = '#fff2cc';
  try { entryYellow = sh.getRange(6, 2).getBackground(); } catch (_) {}

  for (let c = 2; c <= width; c += 2) {
    // Row 5: Sensor Model (pair-merge, paint entry yellow)
    try { sh.getRange(5, c, 1, 2).merge().setBackground(entryYellow); } catch (_) {}

    // Row 6: Pixel Size (µm) — pair-merge (single value), NO labels
    try {
      const r6 = sh.getRange(6, c, 1, 2);
      r6.merge().setBackground(entryYellow).clearNote().clearContent();
    } catch (_) {}

    // Row 7: Sensor size (pixels) — ensure NOT merged; write Width/Height
    try {
      const r7 = sh.getRange(7, c, 1, 2);
      if (r7.isPartOfMerge()) r7.breakApart();
      center_(sh.getRange(7, c)).setValue('Width');
      center_(sh.getRange(7, c + 1)).setValue('Height');
    } catch (_) {}

    // Row 14: Camera Highlight Color — restore DV picker on first col of the pair
    try {
      const dv = SpreadsheetApp.newDataValidation()
        .requireValueInList(COLOR_PICKER.map(r => r[0]), true)
        .setAllowInvalid(true)
        .build();
      sh.getRange(14, c).setDataValidation(dv);
    } catch (_) {}

    // Row 15: Acknowledge Defaults — pair-merge
    try { sh.getRange(15, c, 1, 2).merge(); } catch (_) {}
  }

  // Rig Eligibility metric rows (pair-merge all camera pairs, normal weight)
  [FOV_ROW, IMG_ROW].forEach(r => {
    if (!r) return;
    for (let c = 2; c <= width; c += 2) {
      try { sh.getRange(r, c, 1, 2).merge().setFontWeight('normal'); } catch (_) {}
    }
  });
}

// Paint selected color and drop the text (Camera Highlight Color, row 14)
function camerakit_applyColorChoice_(range) {
  try {
    const sh = range.getSheet();
    if (sh.getName() !== 'Camera Kit') return;
    if (range.getRow() !== 14) return;

    const val = String(range.getDisplayValue() || '').trim();
    if (!val) return;

    const hex = nameToHex_(val);
    if (!hex) return;

    range.setBackground(hex).setValue('');
  } catch (_) {}
  try { camerakit_applyColorChoice_(e.range); } catch (_) {}
}

// ===== CAMERA KIT: Rig Eligibility (checkbox + FOV + Image Scale) =====
function _hpcShadeSafe_(base, amt) {
  try { return (typeof hpcShade === 'function') ? hpcShade(base, amt) : base; } catch(_) { return base; }
}

function camerakit_getCameraBlocks_(sh) {
  const width = getActiveWidth_(sh);
  const blocks = [];
  if (width < 2) return blocks;
  const pairs = Math.floor((width - 1) / 2);
  for (let j = 0; j < pairs; j++) blocks.push({ startCol: 2 + j * 2, width: 2 });
  return blocks;
}

function camerakit_mergeBandHeader_(sh, row) {
  const w = getActiveWidth_(sh);
  if (w >= 1) sh.getRange(row, 1, 1, w).merge();
}

function camerakit_applyRigColors_(camSheet) {
  try {
    const rigs = (typeof getRigData_ === 'function') ? getRigData_() : [];
    if (!camSheet || !rigs.length) return;
    const firstRigRow = CK.ROWS.RIG_HDR + 1;

    rigs.forEach((rig, i) => {
      const r = firstRigRow + i * 3; // first of the triplet
      const hex = (typeof nameToHex_ === 'function') ? (nameToHex_(rig.color) || rig.color) : rig.color;
      if (hex) {
        const dark = (typeof hexIsDark_ === 'function') ? hexIsDark_(hex) : false;
        camSheet.getRange(r, 1).setBackground(hex).setFontColor(dark ? '#FFFFFF' : '#000000');
      }
      camSheet.getRange(r, 1).setValue(rig.name);
    });
  } catch(_) {}
}

function camerakit_rebuildRigEligibility_(sh) {
  if (!sh) sh = SpreadsheetApp.getActive().getSheetByName(CK.NAME || 'Camera Kit');
  if (!sh) return;

  const rigs   = (typeof getRigData_ === 'function') ? getRigData_() : [{ name: 'Rig 1 (Default)', color: '' }];
  const blocks = camerakit_getCameraBlocks_(sh);

  // Header row styling/merge
  const hdr = CK.ROWS.RIG_HDR;
  camerakit_mergeBandHeader_(sh, hdr);
  try {
    const hpc = (typeof getHPC_Global_ === 'function') ? getHPC_Global_() : '#6aa5d9';
    sh.getRange(hdr, 1, 1, getActiveWidth_(sh))
      .setBackground(_hpcShadeSafe_(hpc, 40))
      .setFontColor('#FFFFFF')
      .setFontWeight('bold');
  } catch(_) {}

  // Clear old area under the header
  const startRow  = CK.ROWS.RIG_HDR + 1;
  const totalRows = Math.max(1, rigs.length * 3);
  const width     = getActiveWidth_(sh);
  if (width < 1) return;

  if (sh.getMaxRows() < startRow + totalRows - 1) {
    sh.insertRowsAfter(sh.getMaxRows(), startRow + totalRows - 1 - sh.getMaxRows());
  }

  const area = sh.getRange(startRow, 1, totalRows, width);
  area.clearContent();
  try { area.removeCheckboxes(); } catch (e) {}
  try { area.breakApart(); }     catch (e) {}


  // Build triplets
  rigs.forEach((rig, i) => {
    const r1 = startRow + i * 3;     // checkbox row
    const r2 = r1 + 1;               // FOV row
    const r3 = r1 + 2;               // Image scale row
    [r1, r2, r3].forEach(r => sh.setRowHeight(r, 28));

    sh.getRange(r1, 1).setValue(rig.name);
    sh.getRange(r2, 1).setValue('Field of View (arcminutes)').setFontWeight('normal');
    sh.getRange(r3, 1).setValue('Image Scale (arcsec/pixel)').setFontWeight('normal');

    blocks.forEach(b => {
      sh.getRange(r1, b.startCol, 1, b.width).merge()
        .insertCheckboxes().setHorizontalAlignment('center').setVerticalAlignment('middle');
      sh.getRange(r2, b.startCol, 1, b.width).merge()
        .setValue(0).setHorizontalAlignment('center').setFontWeight('normal');
      sh.getRange(r3, b.startCol, 1, b.width).merge()
        .setValue(0).setHorizontalAlignment('center').setFontWeight('normal');
    });
  });

  camerakit_applyRigColors_(sh);
}

// ==================== CAMERA KIT NORMALIZER ====================
// Two-column camera blocks begin at column 2 (B), then every +2 columns.

function camerakit_getBlocks_(sh) {
  const starts = [];
  const width = getActiveWidth_(sh);
  let c = 2; // B
  while (c <= width) {
    const label = sh.getRange(3, c).getDisplayValue().trim(); // row 3: "Camera 1", "Camera 2", ...
    if (label) starts.push(c);
    c += 2;
  }
  return { starts, span: 2, width };
}

function camerakit_pairMergeRow_(sh, row, startCol, span) {
  sh.getRange(row, startCol, 1, span).merge();
}

function camerakit_labelWidthHeight_(sh, row, startCol) {
  // Ensure two separate cells with helpers
  const r = sh.getRange(row, startCol, 1, 2);
  try { r.breakApart(); } catch (e) {}
  sh.getRange(row, startCol).setValue('Width');
  sh.getRange(row, startCol + 1).setValue('Height');
  center_(sh.getRange(row, startCol, 1, 2)).setFontSize(10);
}

function camerakit_clearPairHelpers_(sh, row, startCol) {
  // Clear any accidental "Width/Height" text in a merged row (Pixel Size row)
  const r = sh.getRange(row, startCol, 1, 2);
  try { r.breakApart(); } catch (e) {}
  r.clearContent();
  // Re-merge so Pixel Size is a single value per camera
  camerakit_pairMergeRow_(sh, row, startCol, 2);
}

function camerakit_mergeAcrossAllBlocks_(sh, row) {
  const { starts, span } = camerakit_getBlocks_(sh);
  starts.forEach(sc => camerakit_pairMergeRow_(sh, row, sc, span));
}

function camerakit_insertCheckboxesRow_(sh, row) {
  const { starts, span } = camerakit_getBlocks_(sh);
  starts.forEach(sc => {
    const cell = sh.getRange(row, sc, 1, span);
    try { cell.merge(); } catch (e) {}
    cell.insertCheckboxes().setHorizontalAlignment('center');
  });
}

function camerakit_fixRigRows_(sh) {
  const rigHdr = findRowWithText_(sh, 'Rig Eligibility');
  if (!rigHdr) return;
  let r = rigHdr + 1;
  const { starts, span } = camerakit_getBlocks_(sh);
  // Merge and add checkboxes for every rig-name row until blank in col A
  while (sh.getRange(r, 1).getDisplayValue().trim()) {
    starts.forEach(sc => {
      const cell = sh.getRange(r, sc, 1, span);
      try { cell.merge(); } catch (e) {}
      cell.insertCheckboxes().setHorizontalAlignment('center');
    });
    // normal font for rig rows
    sh.getRange(r, 1, 1, getActiveWidth_(sh)).setFontWeight('normal');
    r++;
  }
  // keep rig section rows the same height as the rest
  sh.setRowHeights(rigHdr + 1, Math.max(0, r - (rigHdr + 1)), ROW_H_ALL);
}

function camerakit_normalize_(sh) {
  if (!sh || sh.getName() !== 'Camera Kit') return;

  // Locate important rows by label (robust if rows shift)
  const R_CAMERA_MODEL = findRowWithText_(sh, 'Camera Model');
  const R_SENSOR_MODEL = findRowWithText_(sh, 'Sensor Model');
  const R_PIXEL_SIZE   = findRowWithText_(sh, 'Pixel Size');         // "Pixel Size (um)"
  const R_SENSOR_SIZE  = findRowWithText_(sh, 'Sensor size');        // "Sensor size (pixels)"
  const R_COLOR_ROW    = findRowWithText_(sh, 'Camera Highlight Color');
  const R_ACK          = findRowWithText_(sh, 'Acknowledge Defaults');

  const { starts } = camerakit_getBlocks_(sh);

  // Merge per-camera blocks where the value is single-cell per camera
  [R_CAMERA_MODEL, R_SENSOR_MODEL, R_PIXEL_SIZE, R_COLOR_ROW, R_ACK]
    .filter(r => !!r)
    .forEach(row => starts.forEach(sc => camerakit_pairMergeRow_(sh, row, sc, 2)));

  // Make Sensor Model the same warning yellow as the other input rows
  if (R_SENSOR_MODEL) {
    const width = getActiveWidth_(sh);
    sh.getRange(R_SENSOR_MODEL, 2, 1, Math.max(0, width - 1)).setBackground(WARN_YELLOW);
  }

  // Pixel Size: NO "Width/Height" helpers, one merged cell per camera (and yellow)
  if (R_PIXEL_SIZE) {
    starts.forEach(sc => camerakit_clearPairHelpers_(sh, R_PIXEL_SIZE, sc));
    const width = getActiveWidth_(sh);
    sh.getRange(R_PIXEL_SIZE, 2, 1, Math.max(0, width - 1)).setBackground(WARN_YELLOW);
  }

  // Sensor size (pixels): keep the two cells with Width/Height labels
  if (R_SENSOR_SIZE) {
    starts.forEach(sc => camerakit_labelWidthHeight_(sh, R_SENSOR_SIZE, sc));
    const width = getActiveWidth_(sh);
    sh.getRange(R_SENSOR_SIZE, 2, 1, Math.max(0, width - 1)).setBackground(WARN_YELLOW);
  }

  // Acknowledge Defaults: ensure merged-per-camera with a single checkbox per camera
  if (R_ACK) {
    camerakit_insertCheckboxesRow_(sh, R_ACK);
    sh.setRowHeight(R_ACK, ROW_H_ALL);
  }

  // Rig rows: merged-per-camera and checkboxes; normal font; consistent height
  camerakit_fixRigRows_(sh);
}

// Paint camera color and clear text when user picks a color name
function camerakit_handleColorPicker_(e) {
  try {
    const sh = e.source.getActiveSheet();
    if (sh.getName() !== 'Camera Kit') return;
    const colorRow = findRowWithText_(sh, 'Camera Highlight Color');
    if (!colorRow) return;
    const r = e.range.getRow(), c = e.range.getColumn();
    if (r !== colorRow || c < 2) return; // only camera columns

    const v = e.range.getDisplayValue().trim();
    const hex = nameToHex_(v);
    if (hex) {
      e.range.setBackground(hex).setValue(''); // paint and drop the text
    }
  } catch (_) {}
}

// Safe wrapper: call after (re)building Camera Kit or after adding a camera
function camerakit_normalizeNow_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Camera Kit');
  if (sh) camerakit_normalize_(sh);
}


/* ======================= FILTER KIT ======================= */

var FK = { 
  NAME: 'Filter Kit', 
  HIGHLIGHT_COLOR_LABEL: 'Filter Highlight Color', 
  BAND_ID_LABEL: 'Band ID', 
  ROWS: { 
    ADD: 3, 
    MODEL: 4, 
    BAND_ID: 5, 
    BANDWIDTH: 6, 
    PEAK: 7, 
    CWL: 8, 
    HALO: 9, 
    REJECTION: 10, 
    FILTER_SIZE: 11, 
    THICKNESS: 12, 
    SUBSTRATE: 13, 
    COLOR: 14, 
    ACK: 15 
  }
};

const FILTER_BAND_TYPES = ['Ha', 'SII', 'OIII', 'NII', 'Hb', 'L', 'R', 'G', 'B', 'Mg'];
const DROPDOWN_PADDING = ' '.repeat(6);
const FILTER_DEFAULTS = { 
  Ha: { bandwidth: 6, peak: 95, cwl: 656, halo: 'Good', rejection: 4, filterSize: '1.25"', thickness: 3, substrate: 'N/A' }, 
  SII: { bandwidth: 6, peak: 95, cwl: 672, halo: 'Good', rejection: 4, filterSize: '1.25"', thickness: 3, substrate: 'N/A' }, 
  OIII: { bandwidth: 6, peak: 95, cwl: 501, halo: 'Good', rejection: 4, filterSize: '1.25"', thickness: 3, substrate: 'N/A' }, 
  NII: { bandwidth: 3, peak: 95, cwl: 658, halo: 'Good', rejection: 4, filterSize: '1.25"', thickness: 3, substrate: 'N/A' }, 
  Hb: { bandwidth: 8, peak: 95, cwl: 486, halo: 'Good', rejection: 4, filterSize: '1.25"', thickness: 3, substrate: 'N/A' }, 
  L: { bandwidth: 300, peak: 95, cwl: 550, halo: 'Good', rejection: 4, filterSize: '1.25"', thickness: 3, substrate: 'N/A' }, 
  R: { bandwidth: 100, peak: 95, cwl: 620, halo: 'Good', rejection: 4, filterSize: '1.25"', thickness: 3, substrate: 'N/A' }, 
  G: { bandwidth: 100, peak: 95, cwl: 540, halo: 'Good', rejection: 4, filterSize: '1.25"', thickness: 3, substrate: 'N/A' }, 
  B: { bandwidth: 100, peak: 95, cwl: 470, halo: 'Good', rejection: 4, filterSize: '1.25"', thickness: 3, substrate: 'N/A' }, 
  Mg: { bandwidth: 10, peak: 90, cwl: 280, halo: 'Good', rejection: 4, filterSize: '1.25"', thickness: 3, substrate: 'N/A' }
};
const TRANSMISSION_CURVE_DEFAULTS = { 
  'Ha': [[653, 5], [654, 30], [656, 96], [658, 30], [659, 5]], 
  'SII': [[669, 5], [670, 30], [672, 95], [674, 30], [675, 5]], 
  'OIII': [[498, 5], [499, 30], [501, 95], [503, 30], [504, 5]], 
  'NII': [[655, 5], [656, 30], [658, 95], [660, 30], [661, 5]], 
  'Hb': [[483, 5], [484, 30], [486, 95], [488, 30], [489, 5]], 
  'L': [[420, 92], [450, 95], [550, 96], [650, 95], [680, 92]], 
  'R': [[590, 5], [610, 95], [680, 95], [700, 5]], 
  'G': [[490, 5], [510, 95], [580, 95], [600, 5]], 
  'B': [[400, 5], [420, 95], [490, 95], [510, 5]], 
  'Mg': [[277, 5], [278, 30], [280, 90], [282, 30], [283, 5]]
};

function bufferTransmissionCurvesByBlock(sh) {
  const filterBlocks = getFilterBlocks_(sh);
  const curveHeaderRow = findRowWithText_(sh, 'Transmission Curve');
  let buffer = [];
  filterBlocks.forEach((block, idx) => {
    let blockCurves = [];
    let blockBgs = [];
    let headerCell = sh.getRange(FK.ROWS.ADD, block.startCol);
    let filterLabel = headerCell.getDisplayValue();
    let ackValue = sh.getRange(FK.ROWS.ACK, block.startCol).getValue(); // Buffer the checkbox!
    for (let i = 0; i < block.width / 2; i++) {
      const col = block.startCol + (i * 2);
      blockCurves.push(sh.getRange(curveHeaderRow + 2, col, 10, 2).getValues());
      blockBgs.push(sh.getRange(curveHeaderRow + 2, col, 10, 2).getBackgrounds());
    }
    buffer.push({ curves: blockCurves, bgs: blockBgs, width: block.width, label: filterLabel, ack: ackValue });
  });
  return buffer;
}

function restoreTransmissionCurvesByBlock(sh, buffer) {
  const filterBlocks = getFilterBlocks_(sh);
  const curveHeaderRow = findRowWithText_(sh, 'Transmission Curve');
  for (let blockIdx = 0; blockIdx < buffer.length; blockIdx++) {
    if (blockIdx >= filterBlocks.length) break;
    const block = filterBlocks[blockIdx];
    const buf = buffer[blockIdx];
    for (let i = 0; i < block.width / 2; i++) {
      const col = block.startCol + (i * 2);
      sh.getRange(curveHeaderRow + 2, col, 10, 2).setValues(buf.curves[i]);
      sh.getRange(curveHeaderRow + 2, col, 10, 2).setBackgrounds(buf.bgs[i]);
    }
    sh.getRange(FK.ROWS.ADD, block.startCol, 1, block.width).merge().setValue(buf.label);
    sh.getRange(FK.ROWS.ACK, block.startCol).setValue(buf.ack); // Restore the checkbox!
  }
}

function buildFilterKit_(ss) {
  const sh = ss.getSheetByName(FK.NAME) || ss.insertSheet(FK.NAME, 4);
  sh.clear(); sh.setName(FK.NAME);
  sh.setFrozenRows(5);
  while (sh.getMaxColumns() > 1) sh.deleteColumn(2);
  sh.setColumnWidth(1, 160);
  sh.setRowHeights(1, sh.getMaxRows(), ROW_H_ALL);

  sh.getRange('A1').setValue('Filter Kit');
  sh.getRange('A3').setValue('Add Filter...');
  sh.getRange('A4').setValue('Filter Model').setWrap(true);
  sh.getRange('A5').setValue(FK.BAND_ID_LABEL).setWrap(true);
  sh.getRange('A6').setValue('Bandwidth (nm)').setWrap(true);
  sh.getRange('A7').setValue('Peak Transmission (%)').setWrap(true);
  sh.getRange('A8').setValue('Center Wavelength (nm)').setWrap(true);
  sh.getRange('A9').setValue('Halo Performance').setWrap(true);
  sh.getRange('A10').setValue('Off-band Rejection (OD)').setWrap(true);
  sh.getRange('A11').setValue('Filter Size (inch)').setWrap(true);
  sh.getRange('A12').setValue('Parfocal Thickness (mm)').setWrap(true);
  sh.getRange('A13').setValue('Glass Substrate').setWrap(true);
  sh.getRange('A14').setValue(FK.HIGHLIGHT_COLOR_LABEL).setWrap(true);

  sh.getRange(FK.ROWS.ADD, 1).setDataValidation(
    SpreadsheetApp.newDataValidation().requireValueInList(
      ['Add 1-band Filter', 'Add 2-band Filter', 'Add 3-band Filter', 'Add 4-band Filter', 'Cancel'], true
    ).setAllowInvalid(true).build()
  );
  writeRefreshLabel_(
    SpreadsheetApp.getActive().getSheetByName('Filter Kit'), 
    REFRESH_NEUTRAL_BG, 
    REFRESH_CHOICES_FILTER
  );
  const buffer = bufferTransmissionCurvesByBlock(sh);
  SkyPix_AddFilter_('Add 1-band Filter');
  rebuildFilterKitLayout_();
  restoreTransmissionCurvesByBlock(sh, buffer);

  const shKit = SpreadsheetApp.getActive().getSheetByName(FK.NAME);
  const filterBlocks = getFilterBlocks_(shKit);
  if (filterBlocks.length > 0) {
    for (let i = 0; i < filterBlocks[0].width / 2; i++) {
      const bandCol = filterBlocks[0].startCol + (i * 2);
      const bandType = shKit.getRange(FK.ROWS.BAND_ID, bandCol).getDisplayValue().trim().replace(DROPDOWN_PADDING, "");
      if (bandType) populateTransmissionCurve_(shKit, bandCol, bandType);
    }
  }
  centerAllColumns_(shKit);
  filter_autoPatch_();
}

function SkyPix_AddFilter_(command) {
  const sh = SpreadsheetApp.getActive().getSheetByName(FK.NAME);
  if (!sh) return;
  const buffer = bufferTransmissionCurvesByBlock(sh);

  const numBands = parseInt((command || '').replace(/[^0-9]/g, ''), 10);
  if (isNaN(numBands) || numBands < 1) return;

  const defaultBands = numBands === 1 ? ['L'] : numBands === 2 ? ['Ha', 'OIII'] : numBands === 3 ? ['Ha', 'OIII', 'SII'] : numBands === 4 ? ['Ha', 'Hb', 'OIII', 'SII'] : Array(numBands).fill('Ha');  
  const startCol = getActiveWidth_(sh) + 1;
  const numCols = numBands * 2;

  let filterBlocks = getFilterBlocks_(sh);
  let nextFilterNum = filterBlocks.length + 1;

  sh.insertColumnsAfter(startCol - 1, numCols);
  sh.setColumnWidths(startCol, numCols, 45);

  const headerRange = sh.getRange(FK.ROWS.ADD, startCol, 1, numCols);
  center_(headerRange.merge()).setValue(`Filter ${nextFilterNum}`).setFontWeight('bold').setFontSize(12).setNumberFormat('@').clearDataValidations();

  [FK.ROWS.MODEL, FK.ROWS.HALO, FK.ROWS.REJECTION, FK.ROWS.FILTER_SIZE, FK.ROWS.THICKNESS, FK.ROWS.SUBSTRATE, FK.ROWS.COLOR].forEach(row => {
    sh.getRange(row, startCol, 1, numCols).merge().setBackground(WARN_ORANGE).setHorizontalAlignment('center').setVerticalAlignment('middle');
  });

  sh.getRange(FK.ROWS.COLOR, startCol).setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(COLOR_PICKER.map(r => r[0]), true).setAllowInvalid(true).build());
  sh.getRange(FK.ROWS.HALO, startCol).setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(['Excellent', 'Good', 'Fair', 'Poor'], true).setAllowInvalid(true).build());
  
  const bandDv = SpreadsheetApp.newDataValidation().requireValueInList(FILTER_BAND_TYPES, true).setAllowInvalid(true).build();

  for (let i = 0; i < numBands; i++) {
    const currentCol = startCol + (i * 2);
    [FK.ROWS.BAND_ID, FK.ROWS.BANDWIDTH, FK.ROWS.PEAK, FK.ROWS.CWL].forEach(row => sh.getRange(row, currentCol, 1, 2).merge());
    center_(sh.getRange(FK.ROWS.BAND_ID, currentCol))
      .setDataValidation(bandDv)
      .setValue(DROPDOWN_PADDING + defaultBands[i])
      .setBackground(WARN_ORANGE);
    center_(sh.getRange(FK.ROWS.BANDWIDTH, currentCol, 3, 2)).setBackground(WARN_ORANGE);
    populateDefaultBandData_(sh, currentCol, defaultBands[i]);
  }
  
  const firstBandDefaults = FILTER_DEFAULTS[defaultBands[0]];
  if (firstBandDefaults) {
    sh.getRange(FK.ROWS.HALO, startCol).setValue(DROPDOWN_PADDING + firstBandDefaults.halo);
    sh.getRange(FK.ROWS.REJECTION, startCol).setValue(firstBandDefaults.rejection);
    sh.getRange(FK.ROWS.FILTER_SIZE, startCol).setValue(firstBandDefaults.filterSize);
    sh.getRange(FK.ROWS.THICKNESS, startCol).setValue(firstBandDefaults.thickness);
    sh.getRange(FK.ROWS.SUBSTRATE, startCol).setValue(firstBandDefaults.substrate);
  }

  rebuildFilterKitLayout_();

  const filterBlocksAfter = getFilterBlocks_(sh);
  const newBlock = filterBlocksAfter[filterBlocksAfter.length - 1];
  for (let i = 0; i < newBlock.width / 2; i++) {
    const currentCol = newBlock.startCol + (i * 2);
    const bandType = sh.getRange(FK.ROWS.BAND_ID, currentCol).getDisplayValue().trim().replace(DROPDOWN_PADDING, "");
    if (bandType) populateTransmissionCurve_(sh, currentCol, bandType);
  }

  restoreTransmissionCurvesByBlock(sh, buffer);

  centerAllColumns_(sh);
}

function centerAllColumns_(sh) {
  const width = getActiveWidth_(sh);
  if (width > 1) {
    sh.getRange(1, 2, sh.getMaxRows(), width - 1).setHorizontalAlignment('center').setVerticalAlignment('middle');
  }
}

function populateDefaultBandData_(sh, filterCol, bandType) {
  const band = (bandType || '').trim().replace(DROPDOWN_PADDING, '');
  const defaults = FILTER_DEFAULTS[band];
  if (!defaults) return;
  sh.getRange(FK.ROWS.BANDWIDTH, filterCol).setValue(defaults.bandwidth);
  sh.getRange(FK.ROWS.PEAK, filterCol).setValue(defaults.peak);
  sh.getRange(FK.ROWS.CWL, filterCol).setValue(defaults.cwl);
  sh.getRange(FK.ROWS.FILTER_SIZE, filterCol).setValue(defaults.filterSize);
}

function rebuildFilterKitLayout_() {
  const sh = SpreadsheetApp.getActive().getSheetByName(FK.NAME);
  if (!sh) return;
  const lastRow = sh.getLastRow();
  if (lastRow >= FK.ROWS.ACK) sh.deleteRows(FK.ROWS.ACK, lastRow - FK.ROWS.ACK + 1);

  const rigData = getRigData_();
  const eligHeaderRow = FK.ROWS.ACK + 1, rigStartRow = eligHeaderRow + 1;
  const separatorRow = rigStartRow + rigData.length, curveHeaderRow = separatorRow + 1;

  sh.insertRows(FK.ROWS.ACK, 30 - FK.ROWS.ACK + 1);
  sh.setRowHeights(FK.ROWS.ACK, rigData.length + 1, ROW_H_ALL);
  sh.getRange(FK.ROWS.ACK, 1).setValue('Acknowledge Defaults').setWrap(true).setVerticalAlignment('middle');

  mergeFullWidthRow_(sh, eligHeaderRow);
  styleSubheader_(sh.getRange(eligHeaderRow, 1).setValue('Rig Eligibility'), DARK_GREY_FONT);
  mergeFullWidthRow_(sh, separatorRow);
  mergeFullWidthRow_(sh, curveHeaderRow);
  styleSubheader_(sh.getRange(curveHeaderRow, 1).setValue('Transmission Curve'), DARK_GREY_FONT);

  const filterBlocks = getFilterBlocks_(sh);
  filterBlocks.forEach(block => {
    sh.getRange(FK.ROWS.ACK, block.startCol, 1, block.width).merge().insertCheckboxes().setHorizontalAlignment('center');
  });

  rebuildRigEligibility_Filter_(rigData, filterBlocks);
  rebuildTransmissionCurve_(sh, curveHeaderRow, filterBlocks);

  recolorFilterKitBands_(sh);
  applyFilterBorders_(sh, filterBlocks);

  centerAllColumns_(sh);
}

function getFilterBlocks_(sh) {
  const width = getActiveWidth_(sh), blocks = [];
  if (width < 2) return blocks;
  let c = 2;
  while (c <= width) {
    const headCell = sh.getRange(3, c);
    if (headCell.getDisplayValue().startsWith('Filter')) {
      const merged = headCell.getMergedRanges()[0];
      const blockWidth = merged ? merged.getWidth() : 2;
      blocks.push({ startCol: c, width: blockWidth });
      c += blockWidth;
    } else {
      c++;
    }
  }
  return blocks;
}

function getFilterBlockForColumn_(sh, col) {
  return getFilterBlocks_(sh).find(block => col >= block.startCol && col < block.startCol + block.width);
}

function getRigData_() {
  const rigSheet = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!rigSheet || getActiveWidth_(rigSheet) < 2) {
    return [{ name: 'Rig 1 (Default)', color: DEFAULT_HPC }];
  }

  const hdrRow = 3;
  const width  = getActiveWidth_(rigSheet);
  const headerVals = rigSheet.getRange(hdrRow, 2, 1, width - 1).getDisplayValues()[0];
  const rigNames = [];
  for (let i = 0; i < headerVals.length; i += 2) {
    const name = String(headerVals[i] || '').trim();
    if (name) rigNames.push(name);
  }
  if (rigNames.length === 0) return [{ name: 'Rig 1 (Default)', color: DEFAULT_HPC }];

  const colorRow = findRowWithText_(rigSheet, 'Rig highlight color');
  let bgRow = [];
  if (colorRow) {
    bgRow = rigSheet.getRange(colorRow, 2, 1, rigNames.length * 2).getBackgrounds()[0];
  }

  return rigNames.map((name, i) => ({
    name,
    color: bgRow[i * 2] || DEFAULT_HPC
  }));
}

function findRowWithText_(sh, text) {
  const f = sh.createTextFinder(text).findNext();
  return f ? f.getRow() : null;
}

function recolorFilterKitBands_(sh) {
  if (!sh) return;
  const hpc = getHPC_Global_();
  const width = getActiveWidth_(sh);

  const title = sh.getRange(1, 1, 1, width).merge().setBackground(hpcShade(hpc, 80));
  styleSubheader_(title, '#FFFFFF').setFontSize(TITLE_FS);

  const addCell = sh.getRange('A3');
  const addBg = hpcShade(hpc, 20);
  addCell.setBackground(addBg);
  styleSubheader_(addCell, '#FFFFFF');
  stylePaddedCell_(addCell, 'Add Filter...', addBg, '#FFFFFF', true);

  if (width > 1) {
    const headers = sh.getRange(3, 2, 1, width - 1).setBackground(hpcShade(hpc, 40));
    styleSubheader_(headers, '#FFFFFF');
  }

  const eligHeaderRow = findRowWithText_(sh, 'Rig Eligibility');
  const curveHeaderRow = findRowWithText_(sh, 'Transmission Curve');
  if (eligHeaderRow) sh.getRange(eligHeaderRow, 1).setBackground(hpcShade(hpc, 40));
  if (curveHeaderRow) sh.getRange(curveHeaderRow, 1).setBackground(hpcShade(hpc, 40));

  sh.getRange('A4:A15').setHorizontalAlignment('left').setVerticalAlignment('middle').setWrap(true);
  sh.getRange(1, 1, sh.getFrozenRows(), width).setBorder(true, true, true, true, null, true, hpcShade(hpc, 40), SpreadsheetApp.BorderStyle.SOLID);
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, ['Refresh Planner', 'Cancel']);
}

function applyFilterBorders_(sh, filterBlocks) {
  if (!filterBlocks || filterBlocks.length === 0) return;
  const borderColor = hpcShade(getHPC_Global_(), 75);
  const lastRow = 30;
  filterBlocks.forEach(block => {
    sh.getRange(FK.ROWS.MODEL, block.startCol, lastRow - FK.ROWS.MODEL + 1, block.width)
      .setBorder(null, true, null, true, null, null, borderColor, SpreadsheetApp.BorderStyle.SOLID_MEDIUM);
  });
}

function rebuildRigEligibility_Filter_(rigData, filterBlocks) {
  const sh = SpreadsheetApp.getActive().getSheetByName(FK.NAME);
  if (!sh || !rigData || rigData.length === 0 || !filterBlocks) return;
  const startRow = findRowWithText_(sh, 'Rig Eligibility') + 1;
  const width = getActiveWidth_(sh);

  rigData.forEach((rig, i) => {
    const row = startRow + i;
    leftLabel_(sh.getRange(row, 1)).setValue(rig.name);
    const rigHex = normalizeHexOrName_(rig.color);
    sh.getRange(row, 1, 1, width)
      .setBackground(rigHex)
      .setFontColor(hexIsDark_(rigHex) ? '#FFFFFF' : '#000000');

    filterBlocks.forEach(block => {
      sh.getRange(row, block.startCol, 1, block.width).merge().insertCheckboxes().setHorizontalAlignment('center');
    });
  });
}

function rebuildTransmissionCurve_(sh, curveHeaderRow, filterBlocks) {
  if (!curveHeaderRow || !filterBlocks) return;
  const helperRow = curveHeaderRow + 1;
  filterBlocks.forEach(block => {
    for (let i = 0; i < (block.width / 2); i++) {
      const bandCol = block.startCol + (i * 2);
      sh.getRange(helperRow, bandCol).setValue('λ').setHorizontalAlignment('center').setFontWeight('bold');
      sh.getRange(helperRow, bandCol + 1).setValue('%').setHorizontalAlignment('center').setFontWeight('bold');
    }
  });
}

function populateTransmissionCurve_(sheet, column, bandType) {
  const curveData = TRANSMISSION_CURVE_DEFAULTS[bandType.trim().replace(DROPDOWN_PADDING,'')];
  if (!curveData) return;
  const curveHeaderRow = findRowWithText_(sheet, 'Transmission Curve');
  if (!curveHeaderRow) return;
  const block = getFilterBlockForColumn_(sheet, column);
  if (!block) return;

  const bandIndex = Math.floor((column - block.startCol) / 2);
  const targetCol = block.startCol + (bandIndex * 2);
  const dataRange = sheet.getRange(curveHeaderRow + 2, targetCol, 10, 2); 
  dataRange.clearContent();
  sheet.getRange(curveHeaderRow + 2, targetCol, curveData.length, curveData[0].length)
    .setBackground(WARN_ORANGE).setValues(curveData);
}

function handlePlannerUpdate_() {
  const ss = SpreadsheetApp.getActive();
  const plannerSheets = ss.getSheets().filter(s => s.getName().endsWith('Planner'));
  if (plannerSheets.length === 0) {
    ss.toast('No Rig Planners found to update.');
    return;
  }
  const ui = SpreadsheetApp.getUi();
  const response = ui.prompt('Update Rig Planner', 'Enter name of Rig Planner to update:', ui.ButtonSet.OK_CANCEL);
  if (response.getSelectedButton() == ui.Button.OK) {
    const selectedPlanner = response.getResponseText();
    if (plannerSheets.map(s => s.getName()).indexOf(selectedPlanner) > -1) {
      ss.toast(`Updating ${selectedPlanner}... (feature under construction)`);
    } else {
      ui.alert(`Sheet "${selectedPlanner}" is not a valid Rig Planner.`);
    }
  }
}

function populateTransmissionCurve_(sheet, column, bandType) {
  const curveData = TRANSMISSION_CURVE_DEFAULTS[bandType.trim().replace(DROPDOWN_PADDING,'')];
  if (!curveData) return;
  const curveHeaderRow = findRowWithText_(sheet, 'Transmission Curve');
  if (!curveHeaderRow) return;
  const block = getFilterBlockForColumn_(sheet, column);
  if (!block) return;

  const bandIndex = Math.floor((column - block.startCol) / 2);
  const targetCol = block.startCol + (bandIndex * 2);
  const dataRange = sheet.getRange(curveHeaderRow + 2, targetCol, 10, 2); 
  dataRange.clearContent();
  sheet.getRange(curveHeaderRow + 2, targetCol, curveData.length, curveData[0].length)
    .setBackground(WARN_ORANGE).setValues(curveData);
}

function handlePlannerUpdate_() {
  const ss = SpreadsheetApp.getActive();
  const plannerSheets = ss.getSheets().filter(s => s.getName().endsWith('Planner'));
  if (plannerSheets.length === 0) {
    ss.toast('No Rig Planners found to update.');
    return;
  }
  const ui = SpreadsheetApp.getUi();
  const response = ui.prompt('Update Rig Planner', 'Enter name of Rig Planner to update:', ui.ButtonSet.OK_CANCEL);
  if (response.getSelectedButton() == ui.Button.OK) {
    const selectedPlanner = response.getResponseText();
    if (plannerSheets.map(s => s.getName()).indexOf(selectedPlanner) > -1) {
      ss.toast(`Updating ${selectedPlanner}... (feature under construction)`);
    } else {
      ui.alert(`Sheet "${selectedPlanner}" is not a valid Rig Planner.`);
    }
  }
}

// --- Object Entry & Database Modules ---
function buildObjectDatabase_(ss) {
  const sh = ss.getSheetByName("Object Database") || ss.insertSheet("Object Database", 5);
  try {
    sh.clear(); sh.setName("Object Database");
    sh.setFrozenRows(0); sh.setFrozenColumns(0);
    setObjectDatabaseColumnWidths(sh);
    createObjectDatabaseTitleBanner(sh);
    createObjectDatabaseLayout_V3(sh);
    sh.setRowHeights(5, sh.getMaxRows() - 4, 36);
    sh.setFrozenRows(4);
  } catch (error) {
    logDebug_(`Header creation failed: ${error.toString()}`);
    SpreadsheetApp.getUi().alert(`Error building database: ${error.message}`);
  }
  sh.getRange('A5:A').setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(['Smart Search with emission profile update', 'Smart Search with Notes update']).setAllowInvalid(true).setHelpText('Enter an Object ID, or select a Smart Search option.').build());
}

function setObjectDatabaseColumnWidths(sheet) {
  const totalCols = 26;
  const maxCols = sheet.getMaxColumns();
  if (maxCols > totalCols) sheet.deleteColumns(totalCols + 1, maxCols - totalCols);
  if (maxCols < totalCols) sheet.insertColumnsAfter(maxCols, totalCols - maxCols);
  
  const widths = {1: 80, 2: 150, 3: 60, 4: 60, 5: 50, 6: 50, 7: 100, 8: 100};
  for (let col in widths) sheet.setColumnWidth(parseInt(col), widths[col]);
  for (let i = 9; i <= 26; i++) sheet.setColumnWidth(i, 50);
}

function createObjectDatabaseTitleBanner(sheet) {
  const baseColor = getHPC_Global_();
  sheet.getRange('A1:Z1').merge().setValue('Object Database').setBackground(hpcShade(baseColor, 80)).setFontSize(TITLE_FS).setFontWeight('bold').setFontColor('#FFFFFF').setHorizontalAlignment('center').setVerticalAlignment('middle').setBorder(true, true, true, true, true, true, hpcShade(baseColor, 40), SpreadsheetApp.BorderStyle.SOLID);
}

function createObjectDatabaseLayout_V3(sheet) {
  const baseColor = getHPC_Global_();
  const borderColor = hpcShade(baseColor, 40);

  sheet.setRowHeight(1, 36).setRowHeight(2, 36).setRowHeights(3, 2, 25);

  const applyFormatting = (range, label, color) => {
    range.setValue(label).setBackground(color).setFontSize(10).setFontWeight('bold').setFontColor('#434343').setHorizontalAlignment('center').setVerticalAlignment('bottom').setWrap(true).setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);
  };
  
  const sectionHeaders = [{ range: 'A2:H2', label: 'Objects', color: hpcShade(baseColor, 45) }, { range: 'J2:M2', label: 'Emission Profile', color: hpcShade(baseColor, 30) }, { range: 'O2:Z2', label: 'Home Site Transit', color: hpcShade(baseColor, 15) }];
  sectionHeaders.forEach(header => {
    sheet.getRange(header.range).merge().setValue(header.label).setBackground(header.color).setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID).setFontSize(12).setFontWeight('bold').setFontColor('#434343').setHorizontalAlignment('center').setVerticalAlignment('middle');
  });

  const emissionColor = hpcShade(baseColor, 30);
  const smRange = sheet.getRange('I2:I4').merge();
  applyFormatting(smRange, 'Surface Magnitude', emissionColor);
  smRange.setTextRotation(90).setVerticalAlignment('middle');
  const esRange = sheet.getRange('N2:N4').merge();
  applyFormatting(esRange, 'Exposure Strategy', emissionColor);
  esRange.setTextRotation(90).setVerticalAlignment('middle');

  const objectColor = hpcShade(baseColor, 45);
  [{ range: 'A3:A4', label: 'Object ID' }, { range: 'B3:B4', label: 'Object Name' }, { range: 'C3:C4', label: 'RA' }, { range: 'D3:D4', label: 'Dec' }, { range: 'G3:G4', label: 'Image URL' }, { range: 'H3:H4', label: 'Notes' }].forEach(field => { applyFormatting(sheet.getRange(field.range).merge(), field.label, objectColor); });
  [{ range: 'J3:J4', label: 'Ha %' }, { range: 'K3:K4', label: 'OIII %' }, { range: 'L3:L4', label: 'SII %' }, { range: 'M3:M4', label: 'Broadband %' }].forEach(field => { applyFormatting(sheet.getRange(field.range).merge(), field.label, emissionColor); });

  const transitColor = hpcShade(baseColor, 15);
  ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'].forEach((month, i) => {
    applyFormatting(sheet.getRange(3, 15 + i, 2, 1).merge(), month, transitColor);
  });

  const sizeColor = hpcShade(baseColor, 45);
  sheet.getRange('E3:F3').merge().setValue('Size (arcmin)').setBackground(sizeColor).setFontSize(10).setFontWeight('bold').setFontColor('#434343').setHorizontalAlignment('center').setVerticalAlignment('bottom').setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);
  sheet.getRange('E4').setValue('Width').setBackground(sizeColor).setFontColor('#434343').setFontSize(10).setHorizontalAlignment('center').setVerticalAlignment('bottom').setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);
  sheet.getRange('F4').setValue('Height').setBackground(sizeColor).setFontColor('#434343').setFontSize(10).setHorizontalAlignment('center').setVerticalAlignment('bottom').setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);
}
/* ===== RECOLOR — Object Database (HPC reactive) ===== */
function recolorObjectDatabase_(sh) {
  if (!sh) return;

  const hpc        = getHPC_Global_();
  const titleBg    = hpcShade(hpc, 80);
  const objectsBg  = hpcShade(hpc, 45);
  const emissionBg = hpcShade(hpc, 30);
  const transitBg  = hpcShade(hpc, 15);
  const border     = hpcShade(hpc, 40);

  // Title band (A1:Z1)
  sh.getRange(1, 1, 1, 26)
    .setBackground(titleBg)
    .setFontColor('#FFFFFF')
    .setBorder(true, true, true, true, true, true, border, SpreadsheetApp.BorderStyle.SOLID);

  // Major section headers
  sh.getRange('A2:H2').setBackground(objectsBg)
    .setFontColor('#434343').setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID);
  // Emission mini-headers (vertical) + band headers
  sh.getRange('I2:I4')                       // Surface Magnitude (vertical)
    .setBackground(emissionBg)
    .setFontColor('#434343')
    .setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID)
    .setTextRotation(90)
    .setVerticalAlignment('middle');

  sh.getRange('J2:M2')                        // Ha/OIII/SII/Broadband
    .setBackground(emissionBg)
    .setFontColor('#434343')
    .setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID);

  sh.getRange('N2:N4')                        // Exposure Strategy (vertical)
    .setBackground(emissionBg)
    .setFontColor('#434343')
    .setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID)
    .setTextRotation(90)
    .setVerticalAlignment('middle');
    sh.getRange('O2:Z2').setBackground(transitBg)
      .setFontColor('#434343').setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID);

  // Column headers
  ['A3:A4','B3:B4','C3:C4','D3:D4','G3:G4','H3:H4','E3:F3','E4','F4']
    .forEach(r => sh.getRange(r).setBackground(objectsBg)
      .setFontColor('#434343').setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID));

  ['J3:J4','K3:K4','L3:L4','M3:M4']
    .forEach(r => sh.getRange(r).setBackground(emissionBg)
      .setFontColor('#434343').setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID));

  for (let c = 15; c <= 26; c++) {
    sh.getRange(3, c, 2, 1).setBackground(transitBg)
      .setFontColor('#434343').setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID);
  }
}

function _createConfigSheet_(ss) {
  const sheetName = '_config';
  let sheet = ss.getSheetByName(sheetName);
  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
    sheet.hideSheet();
    sheet.getRange('A1:B1').setValues([['Key', 'Value']]).setFontWeight('bold');
  }
}

function _saveApiKeys_(cseKey, cseCx, airnowKey) {
  const sh = SpreadsheetApp.getActive().getSheetByName('_config');
  const data = [
    ['CSE_KEY', cseKey],
    ['CSE_CX', cseCx],
    ['AIRNOW_KEY', airnowKey]
  ];
  sh.getRange('A2:B4').setValues(data);
}

function _loadApiKeys_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('_config');
  if (!sh) return {};
  const data = sh.getRange('A2:B4').getValues();
  const keys = {};
  data.forEach(row => {
    if (row[0]) {
      keys[row[0]] = row[1];
    }
  });
  return keys;
}

function SkyPix_AddObjects_() {
    const sh = SpreadsheetApp.getActive().getSheetByName('Object Database');
    if (!sh) {
        SpreadsheetApp.getActive().toast('Object Database sheet not found.');
        return;
    }
    const lastRow = sh.getLastRow();
    sh.insertRowsAfter(lastRow, 25);
}

function rigkit_restoreColorPicker_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;

  // Count used columns (fallback: max columns)
  const width = Math.max(2, (function getActiveWidthLocal_(s){
    let c = s.getMaxColumns();
    while (c > 1 && !s.getRange(1, c, Math.min(10, s.getMaxRows()))
                   .getDisplayValues().flat().join('').trim()) c--;
    return c;
  })(sh));

  // Anchor below "Display format"
  const dispHdr = findRowWithText_(sh, 'Display format') || 16;

  // Ensure the "Rig highlight color" row exists
  let row = findRowWithText_(sh, 'Rig highlight color');
  if (!row) {
    row = dispHdr + 3;                               // after two format rows
    sh.insertRowBefore(row);
    sh.getRange(row, 1).setValue('Rig highlight color');
  }

  // Use your COLOR_PICKER list if available; otherwise a safe fallback list
  let pickerNames = [];
  if (typeof COLOR_PICKER !== 'undefined' && Array.isArray(COLOR_PICKER)) {
    pickerNames = COLOR_PICKER.map(r => r[0]);
  } else {
    pickerNames = ['Steel Blue','Blue','Deep Blue','Cyan','Light Blue','Cornflower',
                   'Green','Teal','Purple','Magenta','Red','Red Berry','Maroon',
                   'Brown','Slate','Navy','Dk Green'];
  }

  const dv = SpreadsheetApp.newDataValidation()
    .requireValueInList(pickerNames, true)
    .setAllowInvalid(true)
    .build();

  // Apply across all rig columns (B..active)
  sh.getRange(row, 2, 1, Math.max(1, width - 1)).setDataValidation(dv);
  SpreadsheetApp.getActive().toast('Rig color picker restored.');
}

/* ========= AUTO PATCHERS: Camera Kit & Filter Kit ========= */

// Camera Kit: ensure structure, menu, and rig eligibility/colors
function camera_autoPatch_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Camera Kit');
  if (!sh) return;

  const width = getActiveWidth_(sh);

  // Refresh bar: Camera options
  try { writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_CAMERA); } catch (_) {}

  // Ensure Sensor Model row exists (directly under "Camera Model")
  const camModelRow = findRowWithText_(sh, 'Camera Model');
  if (camModelRow) {
    const nextLbl = (sh.getRange(camModelRow + 1, 1).getDisplayValue() || '').trim();
    if (nextLbl !== 'Sensor Model') {
      sh.insertRowsAfter(camModelRow, 1);
      sh.getRange(camModelRow + 1, 1).setValue('Sensor Model');
      if (width > 1) sh.getRange(camModelRow + 1, 2, 1, width - 1).setBackground(WARN_ORANGE);
    }
  }

  // Ensure "Acknowledge Defaults" between "Camera Highlight Color" and "Rig Eligibility"
  const hlRow  = findRowWithText_(sh, 'Camera Highlight Color');
  const eligHr = findRowWithText_(sh, 'Rig Eligibility');
  if (hlRow) {
    const hasAck = findRowWithText_(sh, 'Acknowledge Defaults');
    const wantRow = hlRow + 1; // immediately below highlight color
    const needsAck = !hasAck || !(hasAck > hlRow && (!eligHr || hasAck < eligHr));
    if (needsAck) {
      sh.insertRowsAfter(hlRow, 1);
      sh.getRange(wantRow, 1).setValue('Acknowledge Defaults');
      if (width > 1) sh.getRange(wantRow, 2, 1, width - 1).insertCheckboxes().setHorizontalAlignment('center');
      // leave one natural blank row below (do nothing)
    }
  }

  // Rebuild/refresh Rig Eligibility list and apply rig colors
  camera_rebuildRigEligibility_();
}

function camera_rebuildRigEligibility_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Camera Kit');
  if (!sh) return;

  const width = getActiveWidth_(sh);
  let hdrRow = findRowWithText_(sh, 'Rig Eligibility');
  if (!hdrRow) {
    // If missing, create a header two rows below Acknowledge Defaults (or after Sensor Model block)
    const ack = findRowWithText_(sh, 'Acknowledge Defaults') || findRowWithText_(sh, 'Sensor Model') || 12;
    const newRow = ack + 2;
    sh.insertRows(newRow, 1);
    mergeFullWidthRow_(sh, newRow);
    sh.getRange(newRow, 1).setValue('Rig Eligibility');
    hdrRow = newRow;
  }

  const start = hdrRow + 1;
  const rigData = getRigData_(); // [{name, color}, ...]
  // Clear a reasonable area before writing
  sh.getRange(start, 1, Math.max(1, rigData.length + 6), width)
    .clearContent().clearDataValidations().setBackground(null).setFontWeight('normal');

  rigData.forEach((rig, i) => {
    const r = start + i;
    leftLabel_(sh.getRange(r, 1)).setValue(rig.name);
    // One checkbox column per camera column (B..width)
    if (width > 1) sh.getRange(r, 2, 1, width - 1).insertCheckboxes().setHorizontalAlignment('center');
    // Colorize row with the rig highlight color, if any
    const hex = nameToHex_(rig.color);
    if (hex) {
      sh.getRange(r, 1, 1, width).setBackground(hex).setFontColor(hexIsDark_(hex) ? '#FFFFFF' : '#000000');
    }
  });
}

// Filter Kit: ensure refresh menu + rig eligibility stays in sync
function filter_autoPatch_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Filter Kit');
  if (!sh) return;

  // Refresh bar: Filter options
  try { writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_FILTER); } catch (_) {}

  // Rebuild rig eligibility using existing helpers/blocks
  try {
    const rigData = getRigData_();
    const blocks = getFilterBlocks_(sh); // existing helper in your code
    rebuildRigEligibility_Filter_(rigData, blocks);
  } catch (_) {}
}


